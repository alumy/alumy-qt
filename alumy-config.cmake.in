#############################################################################
# alumy-config.cmake.in - Automatic library discovery and linking configuration
#############################################################################

@PACKAGE_INIT@

# Set basic paths
set(ALUMY_CMAKE_DIR "@PACKAGE_CMAKE_INSTALL_LIBDIR@/cmake/alumy")
set(ALUMY_INCLUDE_DIR "@PACKAGE_CMAKE_INSTALL_INCLUDEDIR@")
set(ALUMY_LIB_DIR "@PACKAGE_CMAKE_INSTALL_LIBDIR@")

# Usage example:
#   find_package(alumy REQUIRED)
#   target_link_libraries(my_target PRIVATE alumy::alumy)

#############################################################################
# Recursive library discovery functions - automatically traverse installation directories to find all library files
#############################################################################

# Recursively scan directories to find all library files
function(alumy_scan_libraries_recursive directory out_static_libs out_shared_libs)
    set(_static_libs)
    set(_shared_libs)
    
    if(NOT IS_DIRECTORY "${directory}")
        set(${out_static_libs} "" PARENT_SCOPE)
        set(${out_shared_libs} "" PARENT_SCOPE)
        return()
    endif()
    
    # Get all files and subdirectories in the directory
    file(GLOB_RECURSE _all_files "${directory}/*")
    
    foreach(_file ${_all_files})
        if(IS_DIRECTORY "${_file}")
            continue()
        endif()
        
        get_filename_component(_filename "${_file}" NAME)
        get_filename_component(_ext "${_file}" EXT)
        
        # Identify static library files (.a, .lib)
        if(_ext STREQUAL ".a" OR _ext STREQUAL ".lib")
            # Exclude certain system libraries and temporary files
            if(NOT _filename MATCHES "^(lib)?crt[0-9].*" AND 
               NOT _filename MATCHES ".*\\.tmp.*" AND
               NOT _filename MATCHES ".*\\.bak.*" AND
               NOT _filename MATCHES ".*debug.*info.*")
                list(APPEND _static_libs "${_file}")
            endif()
        # Identify shared library files (.so, .dll, .dylib)
        elseif(_ext STREQUAL ".so" OR _ext STREQUAL ".dll" OR _ext STREQUAL ".dylib")
            # Exclude version symlinks, keep only actual files
            if(NOT _filename MATCHES ".*\\.so\\.[0-9]+.*")
                list(APPEND _shared_libs "${_file}")
            endif()
        # Handle .so files without extension
        elseif(_filename MATCHES ".*\\.so$")
            list(APPEND _shared_libs "${_file}")
        endif()
    endforeach()
    
    # Remove duplicates and sort
    if(_static_libs)
        list(REMOVE_DUPLICATES _static_libs)
        list(SORT _static_libs)
    endif()
    if(_shared_libs)
        list(REMOVE_DUPLICATES _shared_libs)
        list(SORT _shared_libs)
    endif()
    
    set(${out_static_libs} "${_static_libs}" PARENT_SCOPE)
    set(${out_shared_libs} "${_shared_libs}" PARENT_SCOPE)
endfunction()

#############################################################################
# Smart library selection functions - static libraries first, avoid duplicates
#############################################################################

# Extract library name from library file path
function(alumy_extract_library_name filepath out_libname)
    get_filename_component(_filename "${filepath}" NAME_WE)
    
    # Remove common prefixes
    string(REGEX REPLACE "^lib" "" _clean_name "${_filename}")
    # Remove common suffixes
    string(REGEX REPLACE "[-_](static|shared|debug|release|d)$" "" _clean_name "${_clean_name}")
    
    set(${out_libname} "${_clean_name}" PARENT_SCOPE)
endfunction()

# Prefer static libraries, avoid duplicate linking
function(alumy_select_optimal_libraries static_libs shared_libs out_selected_libs)
    set(_selected_libs)
    set(_processed_names)
    
    # First process all static libraries
    foreach(_static_lib ${static_libs})
        alumy_extract_library_name("${_static_lib}" _lib_name)
        
        # Avoid adding duplicate libraries with same name
        list(FIND _processed_names "${_lib_name}" _name_index)
        if(_name_index EQUAL -1)
            list(APPEND _selected_libs "${_static_lib}")
            list(APPEND _processed_names "${_lib_name}")
        endif()
    endforeach()
    
    # Then process shared libraries (only add those without corresponding static libraries)
    foreach(_shared_lib ${shared_libs})
        alumy_extract_library_name("${_shared_lib}" _lib_name)
        
        # Only add shared library if no corresponding static library exists
        list(FIND _processed_names "${_lib_name}" _name_index)
        if(_name_index EQUAL -1)
            list(APPEND _selected_libs "${_shared_lib}")
            list(APPEND _processed_names "${_lib_name}")
        endif()
    endforeach()
    
    set(${out_selected_libs} "${_selected_libs}" PARENT_SCOPE)
endfunction()

#############################################################################
# Create imported target functions
#############################################################################

# Create IMPORTED target for a single library file
function(alumy_create_imported_target lib_file target_name)
    get_filename_component(_lib_ext "${lib_file}" EXT)
    get_filename_component(_lib_dir "${lib_file}" DIRECTORY)
    
    # Determine library type
    if(_lib_ext STREQUAL ".a" OR _lib_ext STREQUAL ".lib")
        set(_lib_type STATIC)
    else()
        set(_lib_type SHARED)
    endif()
    
    # Create IMPORTED target
    add_library(${target_name} ${_lib_type} IMPORTED)
    set_target_properties(${target_name} PROPERTIES
        IMPORTED_LOCATION "${lib_file}"
    )
    
    # Try to find corresponding header file directory
    get_filename_component(_potential_inc_dir "${_lib_dir}/../include" ABSOLUTE)
    if(IS_DIRECTORY "${_potential_inc_dir}")
        set_target_properties(${target_name} PROPERTIES
            INTERFACE_INCLUDE_DIRECTORIES "${_potential_inc_dir}"
        )
    endif()
    
    # If shared library, set runtime path
    if(_lib_type STREQUAL "SHARED")
        if(NOT WIN32)
            set_target_properties(${target_name} PROPERTIES
                IMPORTED_NO_SONAME FALSE
            )
        endif()
    endif()
endfunction()

#############################################################################
# Main library discovery and configuration functions
#############################################################################

# Automatically discover and configure all dependency libraries
function(alumy_discover_and_configure_libraries)
    message(STATUS "Starting automatic discovery of alumy dependency libraries...")
    
    # Scan all possible library directories
    set(_search_dirs
        "${ALUMY_LIB_DIR}"
        "${CMAKE_INSTALL_PREFIX}/lib"
        "${CMAKE_INSTALL_PREFIX}/lib64"
        "/usr/local/lib"
        "/usr/lib"
        "/opt/local/lib"
    )
    
    set(_all_static_libs)
    set(_all_shared_libs)
    
    # Recursively scan each directory
    foreach(_dir ${_search_dirs})
        if(IS_DIRECTORY "${_dir}")
            alumy_scan_libraries_recursive("${_dir}" _static_libs _shared_libs)
            list(APPEND _all_static_libs ${_static_libs})
            list(APPEND _all_shared_libs ${_shared_libs})
        endif()
    endforeach()
    
    # Select optimal library combination
    alumy_select_optimal_libraries("${_all_static_libs}" "${_all_shared_libs}" _selected_libs)
    
    list(LENGTH _selected_libs _num_libs)
    message(STATUS "Found ${_num_libs} library files")
    
    # Create IMPORTED target for each library
    set(_created_targets)
    foreach(_lib_file ${_selected_libs})
        alumy_extract_library_name("${_lib_file}" _lib_name)
        set(_target_name "alumy::${_lib_name}")
        
        # Avoid creating duplicate targets
        if(NOT TARGET ${_target_name})
            alumy_create_imported_target("${_lib_file}" "${_target_name}")
            list(APPEND _created_targets ${_target_name})
            message(STATUS "  Created target: ${_target_name} <- ${_lib_file}")
        endif()
    endforeach()
    
    # Store created targets in cache variable
    set(ALUMY_DISCOVERED_TARGETS "${_created_targets}" CACHE INTERNAL "Auto-discovered alumy library targets")
endfunction()

#############################################################################
# Advanced linking functions - automatically link all discovered libraries
#############################################################################

# Link all discovered alumy libraries to target
function(alumy_link_all_libraries target_name)
    if(NOT TARGET ${target_name})
        message(FATAL_ERROR "Target ${target_name} does not exist")
    endif()
    
    # If libraries haven't been discovered yet, perform discovery first
    if(NOT DEFINED ALUMY_DISCOVERED_TARGETS)
        alumy_discover_and_configure_libraries()
    endif()
    
    # Get target type to determine appropriate linking approach
    get_target_property(_target_type ${target_name} TYPE)
    
    # Link all discovered libraries
    foreach(_target ${ALUMY_DISCOVERED_TARGETS})
        if(TARGET ${_target})
            # Check the type of the library being linked
            get_target_property(_lib_type ${_target} TYPE)
            
            if(_lib_type STREQUAL "INTERFACE_LIBRARY")
                # INTERFACE libraries must use INTERFACE keyword
                if(_target_type STREQUAL "INTERFACE_LIBRARY")
                    target_link_libraries(${target_name} INTERFACE ${_target})
                else()
                    target_link_libraries(${target_name} PRIVATE ${_target})
                endif()
            elseif(_lib_type STREQUAL "OBJECT_LIBRARY")
                # OBJECT libraries need special handling
                if(_target_type STREQUAL "INTERFACE_LIBRARY")
                    # Cannot link OBJECT libraries to INTERFACE libraries
                    message(STATUS "Skipping OBJECT library ${_target} for INTERFACE target ${target_name}")
                else()
                    target_link_libraries(${target_name} PRIVATE ${_target})
                endif()
            else()
                # Regular STATIC/SHARED libraries
                if(_target_type STREQUAL "INTERFACE_LIBRARY")
                    target_link_libraries(${target_name} INTERFACE ${_target})
                else()
                    target_link_libraries(${target_name} PRIVATE ${_target})
                endif()
            endif()
        endif()
    endforeach()
    
    list(LENGTH ALUMY_DISCOVERED_TARGETS _num_targets)
    message(STATUS "Linked ${_num_targets} libraries to ${target_name}")
endfunction()

#############################################################################
# Qt component automatic discovery
#############################################################################

function(alumy_setup_qt_components)
    # Find Qt components
    set(_qt_components Core Widgets Network SerialPort Multimedia Concurrent)
    
    find_package(QT NAMES Qt6 Qt5 COMPONENTS ${_qt_components} QUIET)
    if(QT_FOUND)
        find_package(Qt${QT_VERSION_MAJOR} COMPONENTS ${_qt_components} REQUIRED)
        
        # Create Qt target aliases
        foreach(_comp ${_qt_components})
            set(_qt_target "Qt${QT_VERSION_MAJOR}::${_comp}")
            if(TARGET ${_qt_target} AND NOT TARGET "alumy::Qt${_comp}")
                add_library("alumy::Qt${_comp}" ALIAS ${_qt_target})
            endif()
        endforeach()
        
        message(STATUS "Configured Qt${QT_VERSION_MAJOR} components: ${_qt_components}")
    endif()
endfunction()

#############################################################################
# System library discovery
#############################################################################

function(alumy_setup_system_libraries)
    # Find common system libraries
    find_library(RT_LIBRARY rt)
    if(RT_LIBRARY AND NOT TARGET alumy::rt)
        add_library(alumy::rt SHARED IMPORTED)
        set_target_properties(alumy::rt PROPERTIES IMPORTED_LOCATION ${RT_LIBRARY})
    endif()
    
    find_library(M_LIBRARY m)
    if(M_LIBRARY AND NOT TARGET alumy::m)
        add_library(alumy::m SHARED IMPORTED)
        set_target_properties(alumy::m PROPERTIES IMPORTED_LOCATION ${M_LIBRARY})
    endif()
    
    find_library(PTHREAD_LIBRARY pthread)
    if(PTHREAD_LIBRARY AND NOT TARGET alumy::pthread)
        add_library(alumy::pthread SHARED IMPORTED)
        set_target_properties(alumy::pthread PROPERTIES IMPORTED_LOCATION ${PTHREAD_LIBRARY})
    endif()
    
    find_library(DL_LIBRARY dl)
    if(DL_LIBRARY AND NOT TARGET alumy::dl)
        add_library(alumy::dl SHARED IMPORTED)
        set_target_properties(alumy::dl PROPERTIES IMPORTED_LOCATION ${DL_LIBRARY})
    endif()
endfunction()

#############################################################################
# Main target creation
#############################################################################

# Check if alumy target exists
include("${CMAKE_CURRENT_LIST_DIR}/alumy-targets.cmake")

# Automatically discover and configure all libraries
alumy_discover_and_configure_libraries()

# Setup Qt components
alumy_setup_qt_components()

# Setup system libraries
alumy_setup_system_libraries()

#############################################################################
# Convenience functions - can be called directly by users
#############################################################################

# Simplified linking function, automatically link alumy and all dependencies
function(target_link_alumy target_name)
    if(NOT TARGET ${target_name})
        message(FATAL_ERROR "Target ${target_name} does not exist")
    endif()
    
    # Get target type to determine appropriate linking approach
    get_target_property(_target_type ${target_name} TYPE)
    
    # Determine link scope based on target type
    if(_target_type STREQUAL "INTERFACE_LIBRARY")
        set(_link_scope INTERFACE)
    else()
        set(_link_scope PRIVATE)
    endif()
    
    # Link main alumy library
    if(TARGET alumy::alumy)
        target_link_libraries(${target_name} ${_link_scope} alumy::alumy)
    endif()
    
    # Automatically link all discovered libraries
    alumy_link_all_libraries(${target_name})
    
    # Link system libraries (only for non-INTERFACE targets)
    if(NOT _target_type STREQUAL "INTERFACE_LIBRARY")
        if(UNIX AND NOT APPLE)
            if(TARGET alumy::rt)
                target_link_libraries(${target_name} ${_link_scope} alumy::rt)
            endif()
        endif()
        
        if(TARGET alumy::m)
            target_link_libraries(${target_name} ${_link_scope} alumy::m)
        endif()
        
        if(TARGET alumy::pthread)
            target_link_libraries(${target_name} ${_link_scope} alumy::pthread)
        endif()
        
        if(TARGET alumy::dl)
            target_link_libraries(${target_name} ${_link_scope} alumy::dl)
        endif()
    endif()
    
    message(STATUS "Completed full alumy dependency configuration for ${target_name}")
endfunction()

#############################################################################
# Debug and information functions
#############################################################################

# Print information about all discovered libraries
function(alumy_print_discovered_libraries)
    message(STATUS "=== Alumy Auto-discovered Libraries ===")
    message(STATUS "Library installation directory: ${ALUMY_LIB_DIR}")
    message(STATUS "Header files directory: ${ALUMY_INCLUDE_DIR}")
    
    if(DEFINED ALUMY_DISCOVERED_TARGETS)
        list(LENGTH ALUMY_DISCOVERED_TARGETS _num_targets)
        message(STATUS "Discovered library targets (${_num_targets} total):")
        foreach(_target ${ALUMY_DISCOVERED_TARGETS})
            if(TARGET ${_target})
                get_target_property(_location ${_target} IMPORTED_LOCATION)
                message(STATUS "  ${_target} -> ${_location}")
            endif()
        endforeach()
    else()
        message(STATUS "Library discovery not yet executed, please call alumy_discover_and_configure_libraries()")
    endif()
    message(STATUS "========================")
endfunction()

# Verify if all targets are available
function(alumy_verify_targets)
    set(_missing_targets)
    
    if(DEFINED ALUMY_DISCOVERED_TARGETS)
        foreach(_target ${ALUMY_DISCOVERED_TARGETS})
            if(NOT TARGET ${_target})
                list(APPEND _missing_targets ${_target})
            endif()
        endforeach()
    endif()
    
    if(_missing_targets)
        message(WARNING "The following targets were not properly created: ${_missing_targets}")
        return()
    endif()
    
    message(STATUS "All alumy targets verified successfully")
endfunction()

#############################################################################
# Final configuration
#############################################################################

# Verify configuration
alumy_verify_targets()

# Set some useful variables for user use
set(ALUMY_VERSION "@PROJECT_VERSION@")
set(ALUMY_VERSION_MAJOR "@PROJECT_VERSION_MAJOR@")
set(ALUMY_VERSION_MINOR "@PROJECT_VERSION_MINOR@")
set(ALUMY_VERSION_PATCH "@PROJECT_VERSION_PATCH@")

message(STATUS "Alumy library configuration completed - version ${ALUMY_VERSION}")
message(STATUS "Use target_link_alumy(your_target) to quickly link all dependencies")
message(STATUS "Use alumy_print_discovered_libraries() to view all available libraries")

# Mark package as found
set(alumy_FOUND TRUE)