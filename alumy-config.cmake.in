@PACKAGE_INIT@

# ==============================================================================
# ALUMY CMAKE CONFIGURATION FILE
# ==============================================================================
# This file configures the alumy library and its dependencies for use in
# external projects. It handles finding and setting up Qt components, system
# libraries, and optional third-party dependencies including gRPC.
#
# Features:
# - Automatic detection of bundled vs system libraries
# - Helper functions for simplified dependency management
# - Debug output control via ALUMY_DEBUG_CMAKE option
# - Support for both legacy and modern CMake target patterns
# ==============================================================================

include(CMakeFindDependencyMacro)

# ==============================================================================
# CONFIGURATION OPTIONS
# ==============================================================================

# Configuration options
option(ALUMY_DEBUG_CMAKE "Enable debug output for alumy CMake configuration" OFF)

# Set up paths
set_and_check(alumy_INCLUDE_DIR "@PACKAGE_CMAKE_INSTALL_INCLUDEDIR@")
set_and_check(alumy_LIB_DIR "@PACKAGE_CMAKE_INSTALL_LIBDIR@")

# Debug helper macro
macro(alumy_debug_message)
    if(ALUMY_DEBUG_CMAKE)
        message(STATUS ${ARGN})
    endif()
endmacro()

# Helper function to create imported library target
function(alumy_create_imported_target target_name library_path include_dirs)
    if(NOT TARGET ${target_name})
        add_library(${target_name} UNKNOWN IMPORTED)
        set_target_properties(${target_name} PROPERTIES
            IMPORTED_LOCATION ${library_path}
        )
        if(include_dirs)
            set_target_properties(${target_name} PROPERTIES
                INTERFACE_INCLUDE_DIRECTORIES "${include_dirs}"
            )
        endif()
        alumy_debug_message("Created imported target: ${target_name} -> ${library_path}")
    endif()
endfunction()

# Helper function to find and create library target
function(alumy_find_and_create_target target_name library_names search_paths include_dirs)
    if(NOT TARGET ${target_name})
        # First try in specified paths (prefer bundled versions)
        find_library(${target_name}_LIBRARY 
            NAMES ${library_names}
            PATHS ${search_paths}
            NO_DEFAULT_PATH
        )
        
        # If not found, fall back to system-wide search
        if(NOT ${target_name}_LIBRARY)
            find_library(${target_name}_LIBRARY 
                NAMES ${library_names}
            )
        endif()
        
        if(${target_name}_LIBRARY)
            alumy_create_imported_target(${target_name} ${${target_name}_LIBRARY} "${include_dirs}")
        else()
            alumy_debug_message("Library not found: ${target_name} (searched: ${library_names})")
        endif()
    endif()
endfunction()

# Find required Qt components
find_dependency(QT NAMES Qt6 Qt5 COMPONENTS Widgets Network Core SerialPort Multimedia Concurrent REQUIRED)
find_dependency(Qt${QT_VERSION_MAJOR} COMPONENTS Widgets Network Core SerialPort Multimedia Concurrent REQUIRED)

# Find system dependencies
if(CMAKE_SYSTEM_NAME STREQUAL "Linux")
    find_library(RT_LIBRARY rt)
    if(RT_LIBRARY)
        list(APPEND alumy_LIBRARIES ${RT_LIBRARY})
    endif()
endif()

find_library(M_LIBRARY m)
if(M_LIBRARY)
    list(APPEND alumy_LIBRARIES ${M_LIBRARY})
endif()

# Find optional third-party dependencies that may have been bundled with alumy

# Save original CMAKE_PREFIX_PATH and add alumy cmake directory for finding bundled dependencies
set(_alumy_original_prefix_path ${CMAKE_PREFIX_PATH})
list(APPEND CMAKE_PREFIX_PATH "${CMAKE_CURRENT_LIST_DIR}")
list(APPEND CMAKE_PREFIX_PATH "${CMAKE_CURRENT_LIST_DIR}/..")

# Also add the package lib and lib/cmake directories so bundled packages are preferred
if(DEFINED alumy_LIB_DIR)
    list(APPEND CMAKE_PREFIX_PATH "${alumy_LIB_DIR}")
    list(APPEND CMAKE_PREFIX_PATH "${alumy_LIB_DIR}/cmake")
endif()

# Try to find spdlog
if(NOT TARGET spdlog::spdlog)
    find_dependency(spdlog QUIET)
endif()

# Find bundled third-party libraries using helper functions
alumy_find_and_create_target(log4qt "log4qt" "${alumy_LIB_DIR}" "${alumy_INCLUDE_DIR}/log4qt")

# Try to find libsndfile
if(NOT TARGET SndFile::sndfile)
    find_dependency(SndFile QUIET)
endif()

alumy_find_and_create_target(qpcpp "qpcpp;libqpcpp" "${alumy_LIB_DIR}" "${alumy_INCLUDE_DIR}")

# Try to find protobuf first (required by gRPC)
if(NOT TARGET protobuf::libprotobuf)
    find_dependency(Protobuf QUIET)
endif()

# Function to setup gRPC libraries
function(alumy_setup_grpc_libraries)
    # Define gRPC component libraries and their alternative names
    set(GRPC_COMPONENTS grpc++ grpc gpr address_sorting upb)
    
    # Create mapping of components to library names
    set(grpc++_NAMES grpc++ libgrpc++)
    set(grpc_NAMES grpc libgrpc)
    set(gpr_NAMES gpr libgpr)
    set(address_sorting_NAMES address_sorting libaddress_sorting)
    set(upb_NAMES upb libupb)
    
    # Find candidate library directories
    set(_ALUMY_GRPC_LIBDIR_CANDIDATES
        ${alumy_LIB_DIR}
        "${PACKAGE_PREFIX_DIR}/grpc-install/lib"
    )
    
    set(alumy_GRPC_LIB_DIR "")
    foreach(_cand IN LISTS _ALUMY_GRPC_LIBDIR_CANDIDATES)
        if(EXISTS "${_cand}/libgrpc++.a" OR EXISTS "${_cand}/libgrpc++.so")
            set(alumy_GRPC_LIB_DIR "${_cand}")
            break()
        endif()
    endforeach()
    
    # Search paths for libraries
    set(_grpc_search_paths ${alumy_GRPC_LIB_DIR} ${alumy_LIB_DIR})
    
    # Find all gRPC libraries
    set(_all_grpc_found TRUE)
    set(_grpc_libraries "")
    
    foreach(comp IN LISTS GRPC_COMPONENTS)
        find_library(${comp}_LIBRARY 
            NAMES ${${comp}_NAMES}
            PATHS ${_grpc_search_paths}
            NO_DEFAULT_PATH
        )
        
        alumy_debug_message("gRPC ${comp}: ${${comp}_LIBRARY}")
        
        if(${comp}_LIBRARY)
            list(APPEND _grpc_libraries ${${comp}_LIBRARY})
        else()
            set(_all_grpc_found FALSE)
        endif()
    endforeach()
    
    # Find zlib (required by gRPC)
    find_library(_zlib_library 
        NAMES z libz
        PATHS ${_grpc_search_paths}
        NO_DEFAULT_PATH
    )
    
    # If not found in bundled paths, search system-wide
    if(NOT _zlib_library)
        find_library(_zlib_library 
            NAMES z libz
        )
    endif()
    
    alumy_debug_message("zlib for gRPC: ${_zlib_library}")
    
    if(_zlib_library)
        list(APPEND _grpc_libraries ${_zlib_library})
        set(alumy_GRPC_ZLIB_LIBRARY ${_zlib_library} PARENT_SCOPE)
    else()
        alumy_debug_message("Warning: zlib not found, gRPC linking may fail")
    endif()
    
    # Find OpenSSL libraries (required by gRPC for encryption) - prioritize installed directories
    set(_openssl_grpc_search_paths
        "${CMAKE_CURRENT_LIST_DIR}/../lib"           # Installed lib directory
        "${CMAKE_CURRENT_LIST_DIR}/../lib64"         # Installed lib64 directory
        "${CMAKE_CURRENT_LIST_DIR}/../openssl-install/lib"  # Installed openssl lib directory
        ${_grpc_search_paths}                        # Build-time paths
    )
    
    find_library(_ssl_library 
        NAMES ssl libssl
        PATHS ${_openssl_grpc_search_paths}
        NO_DEFAULT_PATH
    )
    
    find_library(_crypto_library 
        NAMES crypto libcrypto
        PATHS ${_openssl_grpc_search_paths}
        NO_DEFAULT_PATH
    )
    
    alumy_debug_message("OpenSSL ssl: ${_ssl_library}")
    alumy_debug_message("OpenSSL crypto: ${_crypto_library}")
    
    if(_ssl_library AND _crypto_library)
        # Link crypto before ssl for proper dependency order
        list(APPEND _grpc_libraries ${_crypto_library} ${_ssl_library})
        set(alumy_GRPC_SSL_LIBRARY ${_ssl_library} PARENT_SCOPE)
        set(alumy_GRPC_CRYPTO_LIBRARY ${_crypto_library} PARENT_SCOPE)
    else()
        alumy_debug_message("Warning: OpenSSL not found, gRPC encryption may fail")
    endif()
    
    # Find Abseil libraries (required by gRPC)
    set(_abseil_libraries "")
    set(_abseil_components 
        base synchronization strings str_format_internal 
        random_random hash time status statusor
        raw_logging_internal city low_level_hash civil_time time_zone
        spinlock_wait throw_delegate
        cord cord_internal cordz_functions cordz_handle cordz_info cordz_sample_token
        int128 leak_check leak_check_disable malloc_internal
        random_distributions random_internal_distribution_test_util random_internal_platform
        random_internal_pool_urbg random_internal_randen random_internal_randen_hwaes
        random_internal_randen_hwaes_impl random_internal_randen_slow random_internal_seed_material
        random_seed_gen_exception random_seed_sequences
        stacktrace symbolize demangle_internal
        strings_internal debugging_internal exponential_biased periodic_sampler
    )
    
    foreach(_comp IN LISTS _abseil_components)
        find_library(_abseil_${_comp}_library 
            NAMES absl_${_comp} libabsl_${_comp}
            PATHS ${_grpc_search_paths}
            NO_DEFAULT_PATH
        )
        
        if(_abseil_${_comp}_library)
            list(APPEND _abseil_libraries ${_abseil_${_comp}_library})
        endif()
    endforeach()
    
    # If not found in bundled paths, search system-wide
    if(NOT _abseil_libraries)
        foreach(_comp IN LISTS _abseil_components)
            find_library(_abseil_${_comp}_library 
                NAMES absl_${_comp} libabsl_${_comp}
            )
            
            if(_abseil_${_comp}_library)
                list(APPEND _abseil_libraries ${_abseil_${_comp}_library})
            endif()
        endforeach()
    endif()
    
    alumy_debug_message("Abseil libraries: ${_abseil_libraries}")
    
    if(_abseil_libraries)
        list(APPEND _grpc_libraries ${_abseil_libraries})
        set(alumy_GRPC_ABSEIL_LIBRARIES ${_abseil_libraries} PARENT_SCOPE)
    else()
        alumy_debug_message("Warning: Abseil libraries not found, gRPC may fail")
    endif()
    
    # Handle protobuf libraries if needed
    set(_protobuf_libraries "")
    foreach(pb_comp IN ITEMS protobuf protobuf-lite protoc)
        find_library(${pb_comp}_LIBRARY 
            NAMES ${pb_comp} lib${pb_comp}
            PATHS ${_grpc_search_paths}
            NO_DEFAULT_PATH
        )
        
        # If not found in bundled paths, search system-wide
        if(NOT ${pb_comp}_LIBRARY)
            find_library(${pb_comp}_LIBRARY 
                NAMES ${pb_comp} lib${pb_comp}
            )
        endif()
        
        if(${pb_comp}_LIBRARY)
            list(APPEND _protobuf_libraries ${${pb_comp}_LIBRARY})
            if(NOT TARGET protobuf::lib${pb_comp})
                alumy_create_imported_target(protobuf::lib${pb_comp} ${${pb_comp}_LIBRARY} "${alumy_INCLUDE_DIR}")
            endif()
        endif()
    endforeach()
    
    alumy_debug_message("Protobuf libraries: ${_protobuf_libraries}")
    
    if(_protobuf_libraries)
        list(APPEND _grpc_libraries ${_protobuf_libraries})
        set(alumy_GRPC_PROTOBUF_LIBRARIES ${_protobuf_libraries} PARENT_SCOPE)
    else()
        alumy_debug_message("Warning: Protobuf libraries not found, gRPC may fail")
    endif()
    
    # Find RE2 library (required by gRPC for regex)
    find_library(_re2_library 
        NAMES re2 libre2
        PATHS ${_grpc_search_paths}
        NO_DEFAULT_PATH
    )
    
    # If not found in bundled paths, search system-wide
    if(NOT _re2_library)
        find_library(_re2_library 
            NAMES re2 libre2
        )
    endif()
    
    alumy_debug_message("RE2 library: ${_re2_library}")
    
    if(_re2_library)
        list(APPEND _grpc_libraries ${_re2_library})
        set(alumy_GRPC_RE2_LIBRARY ${_re2_library} PARENT_SCOPE)
    else()
        alumy_debug_message("Warning: RE2 library not found, gRPC regex may fail")
    endif()
    
    # Find c-ares library (required by gRPC for DNS)
    find_library(_cares_library 
        NAMES cares libcares
        PATHS ${_grpc_search_paths}
        NO_DEFAULT_PATH
    )
    
    # If not found in bundled paths, search system-wide
    if(NOT _cares_library)
        find_library(_cares_library 
            NAMES cares libcares
        )
    endif()
    
    alumy_debug_message("c-ares library: ${_cares_library}")
    
    if(_cares_library)
        list(APPEND _grpc_libraries ${_cares_library})
        set(alumy_GRPC_CARES_LIBRARY ${_cares_library} PARENT_SCOPE)
    else()
        alumy_debug_message("Warning: c-ares library not found, gRPC DNS may fail")
    endif()
    
    if(_all_grpc_found)
        # Create both namespaced and non-namespaced targets
        foreach(comp IN LISTS GRPC_COMPONENTS)
            set(_include_dirs "")
            if(comp MATCHES "grpc\\+\\+|grpc$")
                set(_include_dirs "${alumy_INCLUDE_DIR}")
            endif()
            
            # Non-namespaced (legacy)
            alumy_create_imported_target(${comp} ${${comp}_LIBRARY} "${_include_dirs}")
            
            # Namespaced (standard)
            alumy_create_imported_target(gRPC::${comp} ${${comp}_LIBRARY} "${_include_dirs}")
        endforeach()
        
        # Set up dependencies
        set_property(TARGET grpc++ PROPERTY INTERFACE_LINK_LIBRARIES grpc gpr address_sorting upb)
        set_property(TARGET gRPC::grpc++ PROPERTY INTERFACE_LINK_LIBRARIES gRPC::grpc gRPC::gpr gRPC::address_sorting gRPC::upb)
        
        # Store library paths and directory for consumers
        set(alumy_GRPC_LIBRARIES_ABS ${_grpc_libraries} PARENT_SCOPE)
        if(alumy_GRPC_LIB_DIR)
            set(alumy_GRPC_LINK_DIR "${alumy_GRPC_LIB_DIR}" PARENT_SCOPE)
        endif()
    else()
        # Fall back to system-installed gRPC
        find_dependency(gRPC QUIET)
        if(TARGET gRPC::grpc++)
            set(_grpc_system_libs "")
            foreach(comp IN LISTS GRPC_COMPONENTS)
                get_target_property(_loc gRPC::${comp} IMPORTED_LOCATION)
                if(_loc)
                    list(APPEND _grpc_system_libs ${_loc})
                endif()
            endforeach()
            set(alumy_GRPC_LIBRARIES_ABS ${_grpc_system_libs} PARENT_SCOPE)
        endif()
    endif()
endfunction()

# ==============================================================================
# OPENSSL CONFIGURATION
# ==============================================================================

# Function to setup bundled OpenSSL libraries
function(alumy_setup_openssl_libraries)
    # Find bundled OpenSSL libraries - prioritize installed directories
    set(_ALUMY_OPENSSL_LIBDIR_CANDIDATES
        "${CMAKE_CURRENT_LIST_DIR}/../lib"           # Installed lib directory
        "${CMAKE_CURRENT_LIST_DIR}/../lib64"         # Installed lib64 directory
        ${alumy_LIB_DIR}                             # Build-time lib directory
        "${PACKAGE_PREFIX_DIR}/openssl-install/lib"  # Build-time openssl lib directory
    )
    
    set(alumy_OPENSSL_LIB_DIR "")
    foreach(_cand IN LISTS _ALUMY_OPENSSL_LIBDIR_CANDIDATES)
        if(EXISTS "${_cand}/libssl.a" OR EXISTS "${_cand}/libssl.so" OR 
           EXISTS "${_cand}/libcrypto.a" OR EXISTS "${_cand}/libcrypto.so")
            set(alumy_OPENSSL_LIB_DIR "${_cand}")
            break()
        endif()
    endforeach()
    
    # Find bundled OpenSSL include directories - prioritize installed directories
    set(_ALUMY_OPENSSL_INCLUDEDIR_CANDIDATES
        "${CMAKE_CURRENT_LIST_DIR}/../include"           # Installed include directory
        "${CMAKE_CURRENT_LIST_DIR}/../openssl-install/include"  # Installed openssl include directory
        ${alumy_INCLUDE_DIR}                             # Build-time include directory
        "${PACKAGE_PREFIX_DIR}/openssl-install/include"  # Build-time openssl include directory
    )
    
    set(alumy_OPENSSL_INCLUDE_DIR "")
    foreach(_cand IN LISTS _ALUMY_OPENSSL_INCLUDEDIR_CANDIDATES)
        if(EXISTS "${_cand}/openssl/ssl.h")
            set(alumy_OPENSSL_INCLUDE_DIR "${_cand}")
            break()
        endif()
    endforeach()
    
    # Search paths for libraries
    set(_openssl_search_paths ${alumy_OPENSSL_LIB_DIR} ${alumy_LIB_DIR})
    
    # Find bundled OpenSSL libraries
    find_library(_alumy_ssl_library 
        NAMES ssl libssl
        PATHS ${_openssl_search_paths}
        NO_DEFAULT_PATH
    )
    
    find_library(_alumy_crypto_library 
        NAMES crypto libcrypto
        PATHS ${_openssl_search_paths}
        NO_DEFAULT_PATH
    )
    
    alumy_debug_message("OpenSSL ssl library: ${_alumy_ssl_library}")
    alumy_debug_message("OpenSSL crypto library: ${_alumy_crypto_library}")
    alumy_debug_message("OpenSSL include dir: ${alumy_OPENSSL_INCLUDE_DIR}")
    
    # Create imported targets if libraries are found
    if(_alumy_ssl_library AND _alumy_crypto_library)
        # Create crypto target (dependency of ssl)
        if(NOT TARGET OpenSSL::Crypto)
            add_library(OpenSSL::Crypto UNKNOWN IMPORTED)
            set_target_properties(OpenSSL::Crypto PROPERTIES
                IMPORTED_LOCATION ${_alumy_crypto_library}
            )
            if(alumy_OPENSSL_INCLUDE_DIR)
                set_target_properties(OpenSSL::Crypto PROPERTIES
                    INTERFACE_INCLUDE_DIRECTORIES "${alumy_OPENSSL_INCLUDE_DIR}"
                )
            endif()
            alumy_debug_message("Created OpenSSL::Crypto target: ${_alumy_crypto_library}")
        endif()
        
        # Create ssl target  
        if(NOT TARGET OpenSSL::SSL)
            add_library(OpenSSL::SSL UNKNOWN IMPORTED)
            set_target_properties(OpenSSL::SSL PROPERTIES
                IMPORTED_LOCATION ${_alumy_ssl_library}
                INTERFACE_LINK_LIBRARIES OpenSSL::Crypto
            )
            if(alumy_OPENSSL_INCLUDE_DIR)
                set_target_properties(OpenSSL::SSL PROPERTIES
                    INTERFACE_INCLUDE_DIRECTORIES "${alumy_OPENSSL_INCLUDE_DIR}"
                )
            endif()
            alumy_debug_message("Created OpenSSL::SSL target: ${_alumy_ssl_library}")
        endif()
        
        # Store library paths for consumers
        set(alumy_OPENSSL_SSL_LIBRARY ${_alumy_ssl_library} PARENT_SCOPE)
        set(alumy_OPENSSL_CRYPTO_LIBRARY ${_alumy_crypto_library} PARENT_SCOPE)
        set(alumy_OPENSSL_LIBRARIES ${_alumy_crypto_library} ${_alumy_ssl_library} PARENT_SCOPE)
        if(alumy_OPENSSL_INCLUDE_DIR)
            set(alumy_OPENSSL_INCLUDE_DIR ${alumy_OPENSSL_INCLUDE_DIR} PARENT_SCOPE)
        endif()
        
        set(alumy_OPENSSL_FOUND TRUE PARENT_SCOPE)
    else()
        set(alumy_OPENSSL_FOUND FALSE PARENT_SCOPE)
        alumy_debug_message("Bundled OpenSSL not found")
    endif()
endfunction()

# Setup OpenSSL if not already available
if(NOT TARGET OpenSSL::SSL OR NOT TARGET OpenSSL::Crypto)
    alumy_setup_openssl_libraries()
endif()

# Try to find gRPC libraries (prefer bundled ones in alumy first)
if(NOT TARGET gRPC::grpc++)
    alumy_setup_grpc_libraries()
endif()

# ==============================================================================
# TARGET CONFIGURATION
# ==============================================================================

# Include the targets file  
include("${CMAKE_CURRENT_LIST_DIR}/alumy-targets.cmake")

# Ensure alumy target exists 
if(NOT TARGET alumy::alumy)
    message(FATAL_ERROR "alumy::alumy target was not found!")
endif()

# ==============================================================================
# LEGACY COMPATIBILITY VARIABLES
# ==============================================================================

# Provide legacy variables for compatibility  
set(alumy_LIBRARIES alumy::alumy)
set(alumy_INCLUDE_DIRS ${alumy_INCLUDE_DIR})
set(alumy_VERSION @PROJECT_VERSION@)

# ==============================================================================
# QT CONFIGURATION
# ==============================================================================

# Qt library list for convenience
set(_alumy_qt_libs
    Qt${QT_VERSION_MAJOR}::Core
    Qt${QT_VERSION_MAJOR}::Widgets
    Qt${QT_VERSION_MAJOR}::Network
    Qt${QT_VERSION_MAJOR}::SerialPort
    Qt${QT_VERSION_MAJOR}::Multimedia
    Qt${QT_VERSION_MAJOR}::Concurrent
)

# ==============================================================================
# LINKING HELPER FUNCTIONS
# ==============================================================================

# Helper function to determine target scope
function(alumy_get_target_scope target_name out_scope)
    get_target_property(target_type ${target_name} TYPE)
    if(target_type STREQUAL "INTERFACE_LIBRARY")
        set(${out_scope} INTERFACE PARENT_SCOPE)
    else()
        set(${out_scope} PUBLIC PARENT_SCOPE)
    endif()
endfunction()

# Helper function to link core dependencies
function(alumy_link_core_dependencies target_name scope)
    target_link_libraries(${target_name} ${scope} alumy::alumy)
    target_link_libraries(${target_name} ${scope} ${_alumy_qt_libs})
    target_include_directories(${target_name} ${scope} ${alumy_INCLUDE_DIRS})
    target_compile_definitions(${target_name} ${scope} AL_USE_DEFAULT_CONFIG)
endfunction()

# Helper function to link optional third-party dependencies
function(alumy_link_optional_dependencies target_name scope)
    # List of optional dependencies to check and link
    set(_optional_targets 
        spdlog::spdlog
        log4qt
        SndFile::sndfile
        qpcpp
    )
    
    foreach(dep_target IN LISTS _optional_targets)
        if(TARGET ${dep_target})
            target_link_libraries(${target_name} ${scope} ${dep_target})
            alumy_debug_message("Linked optional dependency: ${dep_target} to ${target_name}")
        endif()
    endforeach()
endfunction()

# Helper function to link OpenSSL dependencies
function(alumy_link_openssl_dependencies target_name scope)
    alumy_debug_message("Checking OpenSSL targets for ${target_name}:")
    
    # Setup OpenSSL if not already done
    if(NOT TARGET OpenSSL::SSL OR NOT TARGET OpenSSL::Crypto)
        alumy_setup_openssl_libraries()
    endif()
    
    # Link using standard OpenSSL targets
    if(TARGET OpenSSL::SSL AND TARGET OpenSSL::Crypto)
        target_link_libraries(${target_name} ${scope} OpenSSL::SSL OpenSSL::Crypto)
        alumy_debug_message("Linked bundled OpenSSL using standard targets")
    elseif(alumy_OPENSSL_FOUND AND alumy_OPENSSL_LIBRARIES)
        # Link using absolute paths as fallback
        target_link_libraries(${target_name} ${scope} ${alumy_OPENSSL_LIBRARIES})
        if(alumy_OPENSSL_INCLUDE_DIR)
            target_include_directories(${target_name} ${scope} ${alumy_OPENSSL_INCLUDE_DIR})
        endif()
        alumy_debug_message("Linked bundled OpenSSL using absolute paths: ${alumy_OPENSSL_LIBRARIES}")
    else()
        # Only show warning if OpenSSL is actually required
        # For 3rd-party targets, OpenSSL might be optional
        if(NOT target_name MATCHES "3rd-party")
            message(WARNING "Bundled OpenSSL not found for ${target_name}")
        else()
            alumy_debug_message("Bundled OpenSSL not found for ${target_name} (optional for 3rd-party)")
        endif()
    endif()
endfunction()

# Helper function to link gRPC dependencies
function(alumy_link_grpc_dependencies target_name scope)
    alumy_debug_message("Checking gRPC targets for ${target_name}:")
    
    # Prefer namespaced targets, fall back to non-namespaced
    set(_grpc_targets gRPC::grpc++ grpc++)
    set(_linked_grpc FALSE)
    
    foreach(grpc_target IN LISTS _grpc_targets)
        if(TARGET ${grpc_target})
            alumy_debug_message("Found ${grpc_target}, linking it")
            target_link_libraries(${target_name} ${scope} ${grpc_target})
            target_link_directories(${target_name} ${scope} ${alumy_LIB_DIR})
            if(alumy_GRPC_LINK_DIR)
                target_link_directories(${target_name} ${scope} ${alumy_GRPC_LINK_DIR})
            endif()
            set(_linked_grpc TRUE)
            break()
        endif()
    endforeach()
    
    if(NOT _linked_grpc)
        alumy_debug_message("No gRPC++ target found")
    endif()
    
    # Also link absolute paths to avoid -l resolution issues
    if(alumy_GRPC_LIBRARIES_ABS)
        target_link_libraries(${target_name} ${scope} ${alumy_GRPC_LIBRARIES_ABS})
    endif()
    
    # Link zlib if available (required by gRPC for compression)
    if(alumy_GRPC_ZLIB_LIBRARY)
        target_link_libraries(${target_name} ${scope} ${alumy_GRPC_ZLIB_LIBRARY})
        alumy_debug_message("Linked zlib for gRPC: ${alumy_GRPC_ZLIB_LIBRARY}")
    endif()
    
    # Link OpenSSL if available (required by gRPC for encryption)
    if(alumy_GRPC_SSL_LIBRARY AND alumy_GRPC_CRYPTO_LIBRARY)
        # Link crypto before ssl for proper dependency order
        target_link_libraries(${target_name} ${scope} ${alumy_GRPC_CRYPTO_LIBRARY} ${alumy_GRPC_SSL_LIBRARY})
        alumy_debug_message("Linked OpenSSL for gRPC: ${alumy_GRPC_CRYPTO_LIBRARY} ${alumy_GRPC_SSL_LIBRARY}")
    endif()
    
    # Link Abseil libraries if available (required by gRPC)
    if(alumy_GRPC_ABSEIL_LIBRARIES)
        target_link_libraries(${target_name} ${scope} ${alumy_GRPC_ABSEIL_LIBRARIES})
        alumy_debug_message("Linked Abseil for gRPC: ${alumy_GRPC_ABSEIL_LIBRARIES}")
    endif()
    
    # Link Protobuf libraries if available (required by gRPC)
    if(alumy_GRPC_PROTOBUF_LIBRARIES)
        target_link_libraries(${target_name} ${scope} ${alumy_GRPC_PROTOBUF_LIBRARIES})
        alumy_debug_message("Linked Protobuf for gRPC: ${alumy_GRPC_PROTOBUF_LIBRARIES}")
    endif()
    
    # Link RE2 library if available (required by gRPC for regex)
    if(alumy_GRPC_RE2_LIBRARY)
        target_link_libraries(${target_name} ${scope} ${alumy_GRPC_RE2_LIBRARY})
        alumy_debug_message("Linked RE2 for gRPC: ${alumy_GRPC_RE2_LIBRARY}")
    endif()
    
    # Link c-ares library if available (required by gRPC for DNS)
    if(alumy_GRPC_CARES_LIBRARY)
        target_link_libraries(${target_name} ${scope} ${alumy_GRPC_CARES_LIBRARY})
        alumy_debug_message("Linked c-ares for gRPC: ${alumy_GRPC_CARES_LIBRARY}")
    endif()
endfunction()

# Main function to link all alumy dependencies to a target
function(alumy_link_libraries target_name)
    # Validate target exists
    if(NOT TARGET ${target_name})
        message(FATAL_ERROR "Target '${target_name}' does not exist")
    endif()
    
    # Determine scope based on target type
    alumy_get_target_scope(${target_name} _al_scope)
    
    # Link dependencies in logical groups
    alumy_link_core_dependencies(${target_name} ${_al_scope})
    alumy_link_optional_dependencies(${target_name} ${_al_scope})
    alumy_link_openssl_dependencies(${target_name} ${_al_scope})
    alumy_link_grpc_dependencies(${target_name} ${_al_scope})
    
    alumy_debug_message("Successfully linked all alumy dependencies to ${target_name}")
endfunction()

# Convenience function to link only OpenSSL to a target
function(alumy_link_openssl target_name)
    # Validate target exists
    if(NOT TARGET ${target_name})
        message(FATAL_ERROR "Target '${target_name}' does not exist")
    endif()
    
    # Determine scope based on target type
    alumy_get_target_scope(${target_name} _al_scope)
    
    # Setup OpenSSL if not already done
    if(NOT TARGET OpenSSL::SSL OR NOT TARGET OpenSSL::Crypto)
        alumy_setup_openssl_libraries()
    endif()
    
    # Link OpenSSL dependencies
    alumy_link_openssl_dependencies(${target_name} ${_al_scope})
    
    alumy_debug_message("Successfully linked OpenSSL to ${target_name}")
endfunction()

# Restore original CMAKE_PREFIX_PATH
set(CMAKE_PREFIX_PATH ${_alumy_original_prefix_path})

check_required_components(alumy)
