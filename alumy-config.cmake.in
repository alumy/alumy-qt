@PACKAGE_INIT@

# ==============================================================================
# ALUMY CMAKE CONFIGURATION FILE
# ==============================================================================
# This file configures the alumy library and its dependencies for use in
# external projects. It handles finding and setting up Qt components, system
# libraries, and optional third-party dependencies including gRPC.
#
# Features:
# - Automatic detection of bundled vs system libraries
# - Helper functions for simplified dependency management
# - Debug output control via ALUMY_DEBUG_CMAKE option
# - Support for both legacy and modern CMake target patterns
# ==============================================================================

include(CMakeFindDependencyMacro)

# ==============================================================================
# CONFIGURATION OPTIONS
# ==============================================================================

# Configuration options
option(ALUMY_DEBUG_CMAKE "Enable debug output for alumy CMake configuration" OFF)

# Set up paths
set_and_check(alumy_INCLUDE_DIR "@PACKAGE_CMAKE_INSTALL_INCLUDEDIR@")
set_and_check(alumy_LIB_DIR "@PACKAGE_CMAKE_INSTALL_LIBDIR@")

# Debug helper macro
macro(alumy_debug_message)
    if(ALUMY_DEBUG_CMAKE)
        message(STATUS ${ARGN})
    endif()
endmacro()

# Helper function to create imported library target
function(alumy_create_imported_target target_name library_path include_dirs)
    if(NOT TARGET ${target_name})
        add_library(${target_name} UNKNOWN IMPORTED)
        set_target_properties(${target_name} PROPERTIES
            IMPORTED_LOCATION ${library_path}
        )
        if(include_dirs)
            set_target_properties(${target_name} PROPERTIES
                INTERFACE_INCLUDE_DIRECTORIES "${include_dirs}"
            )
        endif()
        alumy_debug_message("Created imported target: ${target_name} -> ${library_path}")
    endif()
endfunction()

# Helper function to find and create library target
function(alumy_find_and_create_target target_name library_names search_paths include_dirs)
    if(NOT TARGET ${target_name})
        # First try in specified paths (prefer bundled versions)
        find_library(${target_name}_LIBRARY 
            NAMES ${library_names}
            PATHS ${search_paths}
            NO_DEFAULT_PATH
        )
        
        # If not found, fall back to system-wide search
        if(NOT ${target_name}_LIBRARY)
            find_library(${target_name}_LIBRARY 
                NAMES ${library_names}
            )
        endif()
        
        if(${target_name}_LIBRARY)
            alumy_create_imported_target(${target_name} ${${target_name}_LIBRARY} "${include_dirs}")
        else()
            alumy_debug_message("Library not found: ${target_name} (searched: ${library_names})")
        endif()
    endif()
endfunction()

# Find required Qt components
find_dependency(QT NAMES Qt6 Qt5 COMPONENTS Widgets Network Core SerialPort Multimedia Concurrent REQUIRED)
find_dependency(Qt${QT_VERSION_MAJOR} COMPONENTS Widgets Network Core SerialPort Multimedia Concurrent REQUIRED)

# Find system dependencies
if(CMAKE_SYSTEM_NAME STREQUAL "Linux")
    find_library(RT_LIBRARY rt)
    if(RT_LIBRARY)
        list(APPEND alumy_LIBRARIES ${RT_LIBRARY})
    endif()
endif()

find_library(M_LIBRARY m)
if(M_LIBRARY)
    list(APPEND alumy_LIBRARIES ${M_LIBRARY})
endif()

# Find optional third-party dependencies that may have been bundled with alumy

# Save original CMAKE_PREFIX_PATH and add alumy cmake directory for finding bundled dependencies
set(_alumy_original_prefix_path ${CMAKE_PREFIX_PATH})
list(APPEND CMAKE_PREFIX_PATH "${CMAKE_CURRENT_LIST_DIR}")
list(APPEND CMAKE_PREFIX_PATH "${CMAKE_CURRENT_LIST_DIR}/..")

# Also add the package lib and lib/cmake directories so bundled packages are preferred
if(DEFINED alumy_LIB_DIR)
    list(APPEND CMAKE_PREFIX_PATH "${alumy_LIB_DIR}")
    list(APPEND CMAKE_PREFIX_PATH "${alumy_LIB_DIR}/cmake")
endif()

# Try to find spdlog
if(NOT TARGET spdlog::spdlog)
    find_dependency(spdlog QUIET)
endif()

# Find bundled third-party libraries using helper functions
alumy_find_and_create_target(log4qt "log4qt" "${alumy_LIB_DIR}" "${alumy_INCLUDE_DIR}/log4qt")

# Try to find libsndfile
if(NOT TARGET SndFile::sndfile)
    find_dependency(SndFile QUIET)
endif()

alumy_find_and_create_target(qpcpp "qpcpp;libqpcpp" "${alumy_LIB_DIR}" "${alumy_INCLUDE_DIR}")

# Try to find protobuf first (required by gRPC)
if(NOT TARGET protobuf::libprotobuf)
    find_dependency(Protobuf QUIET)
endif()

# Function to setup gRPC libraries
function(alumy_setup_grpc_libraries)
    # Define gRPC component libraries and their alternative names
    set(GRPC_COMPONENTS grpc++ grpc gpr address_sorting upb)
    
    # Create mapping of components to library names
    set(grpc++_NAMES grpc++ libgrpc++)
    set(grpc_NAMES grpc libgrpc)
    set(gpr_NAMES gpr libgpr)
    set(address_sorting_NAMES address_sorting libaddress_sorting)
    set(upb_NAMES upb libupb)
    
    # Find candidate library directories
    set(_ALUMY_GRPC_LIBDIR_CANDIDATES
        ${alumy_LIB_DIR}
        "${PACKAGE_PREFIX_DIR}/grpc-install/lib"
    )
    
    set(alumy_GRPC_LIB_DIR "")
    foreach(_cand IN LISTS _ALUMY_GRPC_LIBDIR_CANDIDATES)
        if(EXISTS "${_cand}/libgrpc++.a" OR EXISTS "${_cand}/libgrpc++.so")
            set(alumy_GRPC_LIB_DIR "${_cand}")
            break()
        endif()
    endforeach()
    
    # Search paths for libraries
    set(_grpc_search_paths ${alumy_GRPC_LIB_DIR} ${alumy_LIB_DIR})
    
    # Find all gRPC libraries
    set(_all_grpc_found TRUE)
    set(_grpc_libraries "")
    
    foreach(comp IN LISTS GRPC_COMPONENTS)
        find_library(${comp}_LIBRARY 
            NAMES ${${comp}_NAMES}
            PATHS ${_grpc_search_paths}
            NO_DEFAULT_PATH
        )
        
        alumy_debug_message("gRPC ${comp}: ${${comp}_LIBRARY}")
        
        if(${comp}_LIBRARY)
            list(APPEND _grpc_libraries ${${comp}_LIBRARY})
        else()
            set(_all_grpc_found FALSE)
        endif()
    endforeach()
    
    # Find zlib (required by gRPC)
    find_library(_zlib_library 
        NAMES z libz
        PATHS ${_grpc_search_paths}
        NO_DEFAULT_PATH
    )
    
    # If not found in bundled paths, search system-wide
    if(NOT _zlib_library)
        find_library(_zlib_library 
            NAMES z libz
        )
    endif()
    
    alumy_debug_message("zlib for gRPC: ${_zlib_library}")
    
    if(_zlib_library)
        list(APPEND _grpc_libraries ${_zlib_library})
        set(alumy_GRPC_ZLIB_LIBRARY ${_zlib_library} PARENT_SCOPE)
    else()
        alumy_debug_message("Warning: zlib not found, gRPC linking may fail")
    endif()
    
    # Handle protobuf libraries if needed
    foreach(pb_comp IN ITEMS protobuf protoc)
        find_library(${pb_comp}_LIBRARY 
            NAMES ${pb_comp} lib${pb_comp}
            PATHS ${_grpc_search_paths}
            NO_DEFAULT_PATH
        )
        if(${pb_comp}_LIBRARY AND NOT TARGET protobuf::lib${pb_comp})
            alumy_create_imported_target(protobuf::lib${pb_comp} ${${pb_comp}_LIBRARY} "${alumy_INCLUDE_DIR}")
        endif()
    endforeach()
    
    if(_all_grpc_found)
        # Create both namespaced and non-namespaced targets
        foreach(comp IN LISTS GRPC_COMPONENTS)
            set(_include_dirs "")
            if(comp MATCHES "grpc\\+\\+|grpc$")
                set(_include_dirs "${alumy_INCLUDE_DIR}")
            endif()
            
            # Non-namespaced (legacy)
            alumy_create_imported_target(${comp} ${${comp}_LIBRARY} "${_include_dirs}")
            
            # Namespaced (standard)
            alumy_create_imported_target(gRPC::${comp} ${${comp}_LIBRARY} "${_include_dirs}")
        endforeach()
        
        # Set up dependencies
        set_property(TARGET grpc++ PROPERTY INTERFACE_LINK_LIBRARIES grpc gpr address_sorting upb)
        set_property(TARGET gRPC::grpc++ PROPERTY INTERFACE_LINK_LIBRARIES gRPC::grpc gRPC::gpr gRPC::address_sorting gRPC::upb)
        
        # Store library paths and directory for consumers
        set(alumy_GRPC_LIBRARIES_ABS ${_grpc_libraries} PARENT_SCOPE)
        if(alumy_GRPC_LIB_DIR)
            set(alumy_GRPC_LINK_DIR "${alumy_GRPC_LIB_DIR}" PARENT_SCOPE)
        endif()
    else()
        # Fall back to system-installed gRPC
        find_dependency(gRPC QUIET)
        if(TARGET gRPC::grpc++)
            set(_grpc_system_libs "")
            foreach(comp IN LISTS GRPC_COMPONENTS)
                get_target_property(_loc gRPC::${comp} IMPORTED_LOCATION)
                if(_loc)
                    list(APPEND _grpc_system_libs ${_loc})
                endif()
            endforeach()
            set(alumy_GRPC_LIBRARIES_ABS ${_grpc_system_libs} PARENT_SCOPE)
        endif()
    endif()
endfunction()

# Try to find gRPC libraries (prefer bundled ones in alumy first)
if(NOT TARGET gRPC::grpc++)
    alumy_setup_grpc_libraries()
endif()

# ==============================================================================
# TARGET CONFIGURATION
# ==============================================================================

# Include the targets file  
include("${CMAKE_CURRENT_LIST_DIR}/alumy-targets.cmake")

# Ensure alumy target exists 
if(NOT TARGET alumy::alumy)
    message(FATAL_ERROR "alumy::alumy target was not found!")
endif()

# ==============================================================================
# LEGACY COMPATIBILITY VARIABLES
# ==============================================================================

# Provide legacy variables for compatibility  
set(alumy_LIBRARIES alumy::alumy)
set(alumy_INCLUDE_DIRS ${alumy_INCLUDE_DIR})
set(alumy_VERSION @PROJECT_VERSION@)

# ==============================================================================
# QT CONFIGURATION
# ==============================================================================

# Qt library list for convenience
set(_alumy_qt_libs
    Qt${QT_VERSION_MAJOR}::Core
    Qt${QT_VERSION_MAJOR}::Widgets
    Qt${QT_VERSION_MAJOR}::Network
    Qt${QT_VERSION_MAJOR}::SerialPort
    Qt${QT_VERSION_MAJOR}::Multimedia
    Qt${QT_VERSION_MAJOR}::Concurrent
)

# ==============================================================================
# LINKING HELPER FUNCTIONS
# ==============================================================================

# Helper function to determine target scope
function(alumy_get_target_scope target_name out_scope)
    get_target_property(target_type ${target_name} TYPE)
    if(target_type STREQUAL "INTERFACE_LIBRARY")
        set(${out_scope} INTERFACE PARENT_SCOPE)
    else()
        set(${out_scope} PUBLIC PARENT_SCOPE)
    endif()
endfunction()

# Helper function to link core dependencies
function(alumy_link_core_dependencies target_name scope)
    target_link_libraries(${target_name} ${scope} alumy::alumy)
    target_link_libraries(${target_name} ${scope} ${_alumy_qt_libs})
    target_include_directories(${target_name} ${scope} ${alumy_INCLUDE_DIRS})
    target_compile_definitions(${target_name} ${scope} AL_USE_DEFAULT_CONFIG)
endfunction()

# Helper function to link optional third-party dependencies
function(alumy_link_optional_dependencies target_name scope)
    # List of optional dependencies to check and link
    set(_optional_targets 
        spdlog::spdlog
        log4qt
        SndFile::sndfile
        qpcpp
    )
    
    foreach(dep_target IN LISTS _optional_targets)
        if(TARGET ${dep_target})
            target_link_libraries(${target_name} ${scope} ${dep_target})
            alumy_debug_message("Linked optional dependency: ${dep_target} to ${target_name}")
        endif()
    endforeach()
endfunction()

# Helper function to link gRPC dependencies
function(alumy_link_grpc_dependencies target_name scope)
    alumy_debug_message("Checking gRPC targets for ${target_name}:")
    
    # Prefer namespaced targets, fall back to non-namespaced
    set(_grpc_targets gRPC::grpc++ grpc++)
    set(_linked_grpc FALSE)
    
    foreach(grpc_target IN LISTS _grpc_targets)
        if(TARGET ${grpc_target})
            alumy_debug_message("Found ${grpc_target}, linking it")
            target_link_libraries(${target_name} ${scope} ${grpc_target})
            target_link_directories(${target_name} ${scope} ${alumy_LIB_DIR})
            if(alumy_GRPC_LINK_DIR)
                target_link_directories(${target_name} ${scope} ${alumy_GRPC_LINK_DIR})
            endif()
            set(_linked_grpc TRUE)
            break()
        endif()
    endforeach()
    
    if(NOT _linked_grpc)
        alumy_debug_message("No gRPC++ target found")
    endif()
    
    # Also link absolute paths to avoid -l resolution issues
    if(alumy_GRPC_LIBRARIES_ABS)
        target_link_libraries(${target_name} ${scope} ${alumy_GRPC_LIBRARIES_ABS})
    endif()
    
    # Link zlib if available (required by gRPC for compression)
    if(alumy_GRPC_ZLIB_LIBRARY)
        target_link_libraries(${target_name} ${scope} ${alumy_GRPC_ZLIB_LIBRARY})
        alumy_debug_message("Linked zlib for gRPC: ${alumy_GRPC_ZLIB_LIBRARY}")
    endif()
endfunction()

# Main function to link all alumy dependencies to a target
function(alumy_link_libraries target_name)
    # Validate target exists
    if(NOT TARGET ${target_name})
        message(FATAL_ERROR "Target '${target_name}' does not exist")
    endif()
    
    # Determine scope based on target type
    alumy_get_target_scope(${target_name} _al_scope)
    
    # Link dependencies in logical groups
    alumy_link_core_dependencies(${target_name} ${_al_scope})
    alumy_link_optional_dependencies(${target_name} ${_al_scope})
    alumy_link_grpc_dependencies(${target_name} ${_al_scope})
    
    alumy_debug_message("Successfully linked all alumy dependencies to ${target_name}")
endfunction()

# Restore original CMAKE_PREFIX_PATH
set(CMAKE_PREFIX_PATH ${_alumy_original_prefix_path})

check_required_components(alumy)
