@PACKAGE_INIT@

# ==============================================================================
# ALUMY CMAKE CONFIGURATION FILE
# ==============================================================================
# Configures alumy library and its dependencies for external projects.
#
# USAGE:
#   find_package(alumy REQUIRED)
#   target_link_libraries(my_target PRIVATE alumy::alumy)
#   alumy_link_libraries(my_target)  # Auto-links all dependencies
# ==============================================================================

include(CMakeFindDependencyMacro)

# ==============================================================================
# BASIC SETUP
# ==============================================================================

option(ALUMY_DEBUG_CMAKE "Enable debug output for alumy CMake configuration" OFF)

# Set up paths
set_and_check(alumy_INCLUDE_DIR "@PACKAGE_CMAKE_INSTALL_INCLUDEDIR@")
set_and_check(alumy_LIB_DIR "@PACKAGE_CMAKE_INSTALL_LIBDIR@")

# Debug helper
macro(alumy_debug_message)
    if(ALUMY_DEBUG_CMAKE)
        message(STATUS ${ARGN})
    endif()
endmacro()

# Helper functions
function(alumy_create_imported_target target_name library_path include_dirs)
    if(NOT TARGET ${target_name})
        add_library(${target_name} UNKNOWN IMPORTED)
        set_target_properties(${target_name} PROPERTIES IMPORTED_LOCATION ${library_path})
        if(include_dirs)
            set_target_properties(${target_name} PROPERTIES INTERFACE_INCLUDE_DIRECTORIES "${include_dirs}")
        endif()
        alumy_debug_message("Created imported target: ${target_name} -> ${library_path}")
    endif()
endfunction()

function(alumy_get_target_scope target_name out_scope)
    get_target_property(target_type ${target_name} TYPE)
    if(target_type STREQUAL "INTERFACE_LIBRARY")
        set(${out_scope} INTERFACE PARENT_SCOPE)
    else()
        set(${out_scope} PUBLIC PARENT_SCOPE)
    endif()
endfunction()

# Auto-discover and link all libraries
function(alumy_discover_and_link_all_libraries target_name)
    if(NOT TARGET ${target_name})
        message(FATAL_ERROR "Target '${target_name}' does not exist")
    endif()
    
    alumy_get_target_scope(${target_name} _al_scope)
    
    # Collect library directories
    set(_LIB_DIRECTORIES "")
    if(DEFINED alumy_LIB_DIR AND EXISTS "${alumy_LIB_DIR}")
        list(APPEND _LIB_DIRECTORIES "${alumy_LIB_DIR}")
    endif()
    
    foreach(_dir IN ITEMS "${CMAKE_CURRENT_LIST_DIR}/../lib" "${CMAKE_CURRENT_LIST_DIR}/../lib64" "${PACKAGE_PREFIX_DIR}/lib" "${PACKAGE_PREFIX_DIR}/lib64")
        if(EXISTS "${_dir}")
            list(APPEND _LIB_DIRECTORIES "${_dir}")
        endif()
    endforeach()
    
    if(_LIB_DIRECTORIES)
        list(REMOVE_DUPLICATES _LIB_DIRECTORIES)
    endif()
    
    alumy_debug_message("Scanning library directories: ${_LIB_DIRECTORIES}")
    
    # Auto-link libraries from directories
    foreach(_lib_dir IN LISTS _LIB_DIRECTORIES)
        alumy_auto_link_all_libraries(${target_name} ${_lib_dir})
    endforeach()
    
    alumy_debug_message("Library discovery completed for ${target_name}")
endfunction()

# Auto-link all libraries in a directory (prefer static libraries)
function(alumy_auto_link_all_libraries target_name lib_directory)
    if(NOT TARGET ${target_name} OR NOT EXISTS "${lib_directory}")
        return()
    endif()
    
    alumy_get_target_scope(${target_name} _al_scope)
    alumy_debug_message("Auto-linking libraries from: ${lib_directory}")
    
    # Find all library files
    file(GLOB_RECURSE lib_files "${lib_directory}/*.a" "${lib_directory}/*.so" "${lib_directory}/*.dll" "${lib_directory}/*.dylib")
    
    # Group by base name and prefer static libraries
    set(lib_groups "")
    foreach(lib_file IN LISTS lib_files)
        get_filename_component(lib_name ${lib_file} NAME)
        get_filename_component(lib_ext ${lib_file} EXT)
        
        # Skip versioned shared libraries
        if(lib_name MATCHES "\\.(so\\.[0-9]+)")
            continue()
        endif()
        
        # Extract base name
        string(REGEX REPLACE "^lib" "" base_name ${lib_name})
        string(REGEX REPLACE "\\.(a|so|dll|dylib)$" "" base_name ${base_name})
        
        # Skip system libraries and invalid names
        if(NOT base_name OR base_name MATCHES "^(gcc|stdc\\+\\+|pthread|dl|m|rt|c)$" OR base_name MATCHES "[^a-zA-Z0-9_+-]")
            continue()
        endif()
        
        # Store library info (prefer .a over others)
        if(NOT lib_${base_name}_file OR lib_ext STREQUAL ".a")
            set(lib_${base_name}_file ${lib_file})
            if(NOT base_name IN_LIST lib_groups)
                list(APPEND lib_groups ${base_name})
            endif()
        endif()
    endforeach()
    
    # Create imported targets and link
    foreach(base_name IN LISTS lib_groups)
        if(lib_${base_name}_file)
            set(target_name_clean "alumy_auto_${base_name}")
            
            if(NOT TARGET ${target_name_clean})
                add_library(${target_name_clean} UNKNOWN IMPORTED)
                set_target_properties(${target_name_clean} PROPERTIES IMPORTED_LOCATION ${lib_${base_name}_file})
                
                # Add include directory if exists
                get_filename_component(_lib_parent_dir ${lib_directory} DIRECTORY)
                foreach(_inc_dir IN ITEMS "${_lib_parent_dir}/include" "${alumy_INCLUDE_DIR}")
                    if(EXISTS "${_inc_dir}")
                        set_target_properties(${target_name_clean} PROPERTIES INTERFACE_INCLUDE_DIRECTORIES "${_inc_dir}")
                        break()
                    endif()
                endforeach()
                
                alumy_debug_message("Created target: ${target_name_clean} -> ${lib_${base_name}_file}")
                
                # Create alias target without alumy_auto_ prefix for convenience
                if(NOT TARGET ${base_name})
                    add_library(${base_name} ALIAS ${target_name_clean})
                    alumy_debug_message("Created alias: ${base_name} -> ${target_name_clean}")
                endif()
            endif()
            
            target_link_libraries(${target_name} ${_al_scope} ${target_name_clean})
        endif()
    endforeach()
    
    alumy_debug_message("Auto-linking completed for ${target_name}")
endfunction()

# Simple dependency resolution (CMake handles most cases automatically)
function(alumy_resolve_library_dependencies target_name)
    alumy_debug_message("Dependency resolution completed for ${target_name}")
endfunction()

# Helper function to find and create library target
function(alumy_find_and_create_target target_name library_names search_paths include_dirs)
    if(NOT TARGET ${target_name})
        # First try in specified paths (prefer bundled versions)
        find_library(${target_name}_LIBRARY 
            NAMES ${library_names}
            PATHS ${search_paths}
            NO_DEFAULT_PATH
        )
        
        # If not found, fall back to system-wide search
        if(NOT ${target_name}_LIBRARY)
            find_library(${target_name}_LIBRARY 
                NAMES ${library_names}
            )
        endif()
        
        if(${target_name}_LIBRARY)
            alumy_create_imported_target(${target_name} ${${target_name}_LIBRARY} "${include_dirs}")
        else()
            alumy_debug_message("Library not found: ${target_name} (searched: ${library_names})")
        endif()
    endif()
endfunction()

# Find required Qt components
find_dependency(QT NAMES Qt6 Qt5 COMPONENTS Widgets Network Core SerialPort Multimedia Concurrent REQUIRED)
find_dependency(Qt${QT_VERSION_MAJOR} COMPONENTS Widgets Network Core SerialPort Multimedia Concurrent REQUIRED)

# Find system dependencies
if(CMAKE_SYSTEM_NAME STREQUAL "Linux")
    find_library(RT_LIBRARY rt)
    if(RT_LIBRARY)
        list(APPEND alumy_LIBRARIES ${RT_LIBRARY})
    endif()
endif()

find_library(M_LIBRARY m)
if(M_LIBRARY)
    list(APPEND alumy_LIBRARIES ${M_LIBRARY})
endif()

# Find optional third-party dependencies that may have been bundled with alumy

# Save original CMAKE_PREFIX_PATH and add alumy cmake directory for finding bundled dependencies
set(_alumy_original_prefix_path ${CMAKE_PREFIX_PATH})
list(APPEND CMAKE_PREFIX_PATH "${CMAKE_CURRENT_LIST_DIR}")
list(APPEND CMAKE_PREFIX_PATH "${CMAKE_CURRENT_LIST_DIR}/..")

# Discover cmake packages
function(alumy_discover_cmake_packages)
    # Add lib/cmake directories to search path
    if(DEFINED alumy_LIB_DIR)
        foreach(_dir IN ITEMS "${alumy_LIB_DIR}/cmake" "${CMAKE_CURRENT_LIST_DIR}/../lib/cmake" "${CMAKE_CURRENT_LIST_DIR}/../lib64/cmake")
            if(EXISTS "${_dir}")
                list(APPEND CMAKE_PREFIX_PATH "${_dir}")
                alumy_debug_message("Added cmake package directory: ${_dir}")
            endif()
        endforeach()
        set(CMAKE_PREFIX_PATH ${CMAKE_PREFIX_PATH} PARENT_SCOPE)
    endif()
    
    # Try common packages
    foreach(_package IN ITEMS spdlog gRPC Protobuf OpenSSL Boost fmt nlohmann_json yaml-cpp jsoncpp curl sqlite3 opencv4 SndFile)
        if(NOT TARGET ${_package} AND NOT TARGET ${_package}::${_package})
            find_package(${_package} QUIET)
            if(${_package}_FOUND OR TARGET ${_package})
                alumy_debug_message("Found cmake package: ${_package}")
            endif()
        endif()
    endforeach()
endfunction()

# Discover pkg-config packages
function(alumy_discover_pkgconfig_packages)
    find_package(PkgConfig QUIET)
    if(NOT PKG_CONFIG_FOUND)
        return()
    endif()
    
    # Try common packages
    foreach(_pkg IN ITEMS openssl libssl libcrypto libpng sqlite3 libxml-2.0 libcurl zlib freetype2)
        pkg_check_modules(${_pkg}_PC ${_pkg} QUIET)
        if(${_pkg}_PC_FOUND)
            alumy_debug_message("Found pkg-config package: ${_pkg}")
            
            # Create imported target
            string(REPLACE "-" "_" _target_name "alumy_pkg_${_pkg}")
            string(REPLACE "." "_" _target_name ${_target_name})
            
            if(NOT TARGET ${_target_name})
                add_library(${_target_name} INTERFACE IMPORTED)
                if(${_pkg}_PC_INCLUDE_DIRS)
                    set_target_properties(${_target_name} PROPERTIES INTERFACE_INCLUDE_DIRECTORIES "${${_pkg}_PC_INCLUDE_DIRS}")
                endif()
                if(${_pkg}_PC_LIBRARIES)
                    set_target_properties(${_target_name} PROPERTIES INTERFACE_LINK_LIBRARIES "${${_pkg}_PC_LIBRARIES}")
                endif()
                alumy_debug_message("Created pkg-config target: ${_target_name}")
            endif()
        endif()
    endforeach()
endfunction()

# Also add the package lib and lib/cmake directories so bundled packages are preferred
if(DEFINED alumy_LIB_DIR)
    list(APPEND CMAKE_PREFIX_PATH "${alumy_LIB_DIR}")
    list(APPEND CMAKE_PREFIX_PATH "${alumy_LIB_DIR}/cmake")
endif()

# Auto-discover cmake packages first
alumy_discover_cmake_packages()

# Auto-discover pkg-config packages
alumy_discover_pkgconfig_packages()

# Try to find spdlog
if(NOT TARGET spdlog::spdlog)
    find_dependency(spdlog QUIET)
endif()

# Try to find protobuf first (required by gRPC)
if(NOT TARGET protobuf::libprotobuf)
    find_dependency(Protobuf QUIET)
endif()

# Setup gRPC libraries
function(alumy_setup_grpc_libraries)
    # Find gRPC library directory
    foreach(_cand IN ITEMS ${alumy_LIB_DIR} "${CMAKE_CURRENT_LIST_DIR}/../lib")
        if(EXISTS "${_cand}/libgrpc++.a" OR EXISTS "${_cand}/libgrpc++.so")
            set(alumy_GRPC_LIB_DIR "${_cand}")
            break()
        endif()
    endforeach()
    
    if(alumy_GRPC_LIB_DIR)
        alumy_debug_message("Found gRPC library directory: ${alumy_GRPC_LIB_DIR}")
        set(alumy_GRPC_LINK_DIR "${alumy_GRPC_LIB_DIR}" PARENT_SCOPE)
        
        # Create gRPC targets
        foreach(comp IN ITEMS grpc++ grpc)
            find_library(${comp}_LIBRARY NAMES ${comp} PATHS ${alumy_GRPC_LIB_DIR} NO_DEFAULT_PATH)
            if(${comp}_LIBRARY AND NOT TARGET gRPC::${comp})
                alumy_create_imported_target(gRPC::${comp} ${${comp}_LIBRARY} "${alumy_INCLUDE_DIR}")
            endif()
        endforeach()
    else()
        find_dependency(gRPC QUIET)
    endif()
endfunction()

# ==============================================================================
# OPENSSL CONFIGURATION
# ==============================================================================

# Setup OpenSSL libraries
function(alumy_setup_openssl_libraries)
    # Find OpenSSL library directory
    foreach(_cand IN ITEMS "${CMAKE_CURRENT_LIST_DIR}/../lib" ${alumy_LIB_DIR})
        if(EXISTS "${_cand}/libssl.a" OR EXISTS "${_cand}/libssl.so" OR EXISTS "${_cand}/libcrypto.a" OR EXISTS "${_cand}/libcrypto.so")
            set(alumy_OPENSSL_LIB_DIR "${_cand}")
            break()
        endif()
    endforeach()
    
    if(alumy_OPENSSL_LIB_DIR)
        alumy_debug_message("Found OpenSSL library directory: ${alumy_OPENSSL_LIB_DIR}")
        set(alumy_OPENSSL_LINK_DIR "${alumy_OPENSSL_LIB_DIR}" PARENT_SCOPE)
        
        # Create OpenSSL targets
        find_library(_ssl_lib NAMES ssl PATHS ${alumy_OPENSSL_LIB_DIR} NO_DEFAULT_PATH)
        find_library(_crypto_lib NAMES crypto PATHS ${alumy_OPENSSL_LIB_DIR} NO_DEFAULT_PATH)
        
        if(_ssl_lib AND _crypto_lib)
            if(NOT TARGET OpenSSL::Crypto)
                add_library(OpenSSL::Crypto UNKNOWN IMPORTED)
                set_target_properties(OpenSSL::Crypto PROPERTIES IMPORTED_LOCATION ${_crypto_lib})
            endif()
            if(NOT TARGET OpenSSL::SSL)
                add_library(OpenSSL::SSL UNKNOWN IMPORTED)
                set_target_properties(OpenSSL::SSL PROPERTIES 
                    IMPORTED_LOCATION ${_ssl_lib}
                    INTERFACE_LINK_LIBRARIES OpenSSL::Crypto)
            endif()
        endif()
    endif()
endfunction()

# Setup OpenSSL if not already available
if(NOT TARGET OpenSSL::SSL OR NOT TARGET OpenSSL::Crypto)
    alumy_setup_openssl_libraries()
endif()

# Try to find gRPC libraries (prefer bundled ones in alumy first)
if(NOT TARGET gRPC::grpc++)
    alumy_setup_grpc_libraries()
endif()

# ==============================================================================
# TARGET CONFIGURATION
# ==============================================================================

# Include the targets file  
include("${CMAKE_CURRENT_LIST_DIR}/alumy-targets.cmake")

# Ensure alumy target exists 
if(NOT TARGET alumy::alumy)
    message(FATAL_ERROR "alumy::alumy target was not found!")
endif()

# ==============================================================================
# LEGACY COMPATIBILITY VARIABLES
# ==============================================================================

# Provide legacy variables for compatibility  
set(alumy_LIBRARIES alumy::alumy)
set(alumy_INCLUDE_DIRS ${alumy_INCLUDE_DIR})
set(alumy_VERSION @PROJECT_VERSION@)

# ==============================================================================
# QT CONFIGURATION
# ==============================================================================

# Qt library list for convenience
set(_alumy_qt_libs
    Qt${QT_VERSION_MAJOR}::Core
    Qt${QT_VERSION_MAJOR}::Widgets
    Qt${QT_VERSION_MAJOR}::Network
    Qt${QT_VERSION_MAJOR}::SerialPort
    Qt${QT_VERSION_MAJOR}::Multimedia
    Qt${QT_VERSION_MAJOR}::Concurrent
)

# ==============================================================================
# LINKING HELPER FUNCTIONS
# ==============================================================================

# Link core dependencies
function(alumy_link_core_dependencies target_name scope)
    target_link_libraries(${target_name} ${scope} alumy::alumy ${_alumy_qt_libs})
    target_include_directories(${target_name} ${scope} ${alumy_INCLUDE_DIRS})
    target_compile_definitions(${target_name} ${scope} AL_USE_DEFAULT_CONFIG)
endfunction()

# Link optional dependencies
function(alumy_link_optional_dependencies target_name scope)
    foreach(dep_target IN ITEMS spdlog::spdlog log4qt SndFile::sndfile qpcpp)
        if(TARGET ${dep_target})
            target_link_libraries(${target_name} ${scope} ${dep_target})
            alumy_debug_message("Linked optional dependency: ${dep_target}")
        endif()
    endforeach()
endfunction()

# Link OpenSSL dependencies
function(alumy_link_openssl_dependencies target_name scope)
    if(NOT TARGET OpenSSL::SSL)
        alumy_setup_openssl_libraries()
    endif()
    
    if(TARGET OpenSSL::SSL)
        target_link_libraries(${target_name} ${scope} OpenSSL::SSL OpenSSL::Crypto)
        alumy_debug_message("Linked OpenSSL targets")
    endif()
    
    if(alumy_OPENSSL_LINK_DIR)
        alumy_auto_link_all_libraries(${target_name} ${alumy_OPENSSL_LINK_DIR})
    endif()
endfunction()

# Link gRPC dependencies
function(alumy_link_grpc_dependencies target_name scope)
    foreach(grpc_target IN ITEMS gRPC::grpc++ grpc++)
        if(TARGET ${grpc_target})
            target_link_libraries(${target_name} ${scope} ${grpc_target})
            alumy_debug_message("Linked gRPC target: ${grpc_target}")
            return()
        endif()
    endforeach()
    
    if(alumy_GRPC_LINK_DIR)
        alumy_auto_link_all_libraries(${target_name} ${alumy_GRPC_LINK_DIR})
    endif()
endfunction()

# Main function to link all alumy dependencies
function(alumy_link_libraries target_name)
    if(NOT TARGET ${target_name})
        message(FATAL_ERROR "Target '${target_name}' does not exist")
    endif()
    
    alumy_get_target_scope(${target_name} _al_scope)
    
    # Link core dependencies
    alumy_link_core_dependencies(${target_name} ${_al_scope})
    
    # Auto-discover and link all libraries
    alumy_discover_and_link_all_libraries(${target_name})
    
    # Link optional dependencies
    alumy_link_optional_dependencies(${target_name} ${_al_scope})
    alumy_link_openssl_dependencies(${target_name} ${_al_scope})
    alumy_link_grpc_dependencies(${target_name} ${_al_scope})
    
    alumy_resolve_library_dependencies(${target_name})
    alumy_debug_message("Successfully linked all dependencies to ${target_name}")
endfunction()

# Link only OpenSSL
function(alumy_link_openssl target_name)
    if(NOT TARGET ${target_name})
        message(FATAL_ERROR "Target '${target_name}' does not exist")
    endif()
    
    alumy_get_target_scope(${target_name} _al_scope)
    alumy_link_openssl_dependencies(${target_name} ${_al_scope})
    alumy_debug_message("Successfully linked OpenSSL to ${target_name}")
endfunction()

# Auto-link libraries from directory
function(alumy_auto_link_libraries target_name lib_directory)
    if(NOT TARGET ${target_name})
        message(FATAL_ERROR "Target '${target_name}' does not exist")
    endif()
    
    if(NOT lib_directory)
        alumy_discover_and_link_all_libraries(${target_name})
    else()
        alumy_auto_link_all_libraries(${target_name} ${lib_directory})
    endif()
    
    alumy_debug_message("Successfully auto-linked libraries to ${target_name}")
endfunction()

# Discover all libraries
function(alumy_discover_all_libraries target_name)
    if(NOT TARGET ${target_name})
        message(FATAL_ERROR "Target '${target_name}' does not exist")
    endif()
    
    alumy_discover_and_link_all_libraries(${target_name})
    alumy_debug_message("Successfully discovered all libraries for ${target_name}")
endfunction()

# Restore original CMAKE_PREFIX_PATH
set(CMAKE_PREFIX_PATH ${_alumy_original_prefix_path})

check_required_components(alumy)

