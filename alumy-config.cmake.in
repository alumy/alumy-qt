#############################################################################
# alumy-config.cmake.in - Manual library configuration
#############################################################################

@PACKAGE_INIT@

# Set basic paths
set(ALUMY_CMAKE_DIR "@PACKAGE_CMAKE_INSTALL_LIBDIR@/cmake/alumy")
set(ALUMY_INCLUDE_DIR "@PACKAGE_CMAKE_INSTALL_INCLUDEDIR@")
set(ALUMY_LIB_DIR "@PACKAGE_CMAKE_INSTALL_LIBDIR@")

# Usage example:
#   find_package(alumy REQUIRED)
#   target_link_libraries(my_target PRIVATE alumy::alumy)

message(STATUS "Alumy library configuration - manual setup mode")
message(STATUS "Library directory: ${ALUMY_LIB_DIR}")
message(STATUS "Include directory: ${ALUMY_INCLUDE_DIR}")

# Resolve install prefix and candidate lib directories (handle lib vs lib64)
get_filename_component(ALUMY_PREFIX_DIR "${ALUMY_LIB_DIR}" DIRECTORY)
set(ALUMY_LIB_DIR_CANDIDATES "${ALUMY_LIB_DIR};${ALUMY_PREFIX_DIR}/lib;${ALUMY_PREFIX_DIR}/lib64")

#############################################################################
# Include the main alumy targets
#############################################################################

include("${CMAKE_CURRENT_LIST_DIR}/alumy-targets.cmake")

# Try to locate dependency packages from Alumy install only (no system search)
function(alumy_try_find_local_config pkg_name subdir)
    set(_paths "")
    foreach(_libdir ${ALUMY_LIB_DIR_CANDIDATES})
        list(APPEND _paths "${_libdir}/cmake/${subdir}")
    endforeach()
    find_package(${pkg_name} CONFIG QUIET PATHS ${_paths} NO_DEFAULT_PATH)
endfunction()

# Prefer local package configs for common deps providing CMake targets
alumy_try_find_local_config(absl absl)
alumy_try_find_local_config(absl abseil-cpp)
alumy_try_find_local_config(re2 re2)
alumy_try_find_local_config(Protobuf protobuf)
alumy_try_find_local_config(gRPC gRPC)
alumy_try_find_local_config(c-ares c-ares)

# Use Boost's native cmake package configuration
alumy_try_find_local_config(Boost Boost-1.75.0)
alumy_try_find_local_config(boost_headers boost_headers-1.75.0)

# Find specific Boost components using their native cmake configs
set(_boost_components system filesystem thread chrono date_time regex serialization iostreams program_options)
foreach(_comp ${_boost_components})
    alumy_try_find_local_config(boost_${_comp} boost_${_comp}-1.75.0)
endforeach()

# Set Boost variables for downstream projects to find headers
set(BOOST_ROOT "${ALUMY_PREFIX_DIR}" CACHE PATH "Boost root directory")
set(BOOST_INCLUDEDIR "${ALUMY_INCLUDE_DIR}" CACHE PATH "Boost include directory")
set(BOOST_LIBRARYDIR "${ALUMY_LIB_DIR}" CACHE PATH "Boost library directory")
set(Boost_NO_SYSTEM_PATHS ON CACHE BOOL "Do not search system paths for Boost")
set(Boost_USE_STATIC_LIBS ON CACHE BOOL "Use static Boost libraries")

# Create fallback Boost::headers target if native config didn't work
if(NOT TARGET Boost::headers AND EXISTS "${ALUMY_INCLUDE_DIR}/boost")
    add_library(Boost::headers INTERFACE IMPORTED)
    set_target_properties(Boost::headers PROPERTIES
        INTERFACE_INCLUDE_DIRECTORIES "${ALUMY_INCLUDE_DIR}"
        INTERFACE_SYSTEM_INCLUDE_DIRECTORIES "${ALUMY_INCLUDE_DIR}"
        INTERFACE_COMPILE_DEFINITIONS "BOOST_ALL_NO_LIB"
    )
    message(STATUS "Created fallback Boost::headers target")
endif()

# Create Boost::boost alias for compatibility
if(TARGET Boost::headers AND NOT TARGET Boost::boost)
    add_library(Boost::boost ALIAS Boost::headers)
endif()

message(STATUS "Boost configuration completed using native cmake packages")

# Ensure alumy::alumy propagates usage requirements via INTERFACE link libs
function(_alumy_append_if_target tgt var)
    if(TARGET ${tgt})
        set(${var} "${${var}};${tgt}" PARENT_SCOPE)
    endif()
endfunction()

set(_alumy_usage_libs "")
_alumy_append_if_target(Threads::Threads _alumy_usage_libs)
_alumy_append_if_target(OpenSSL::SSL _alumy_usage_libs)
_alumy_append_if_target(OpenSSL::Crypto _alumy_usage_libs)
_alumy_append_if_target(ZLIB::ZLIB _alumy_usage_libs)
_alumy_append_if_target(protobuf::libprotobuf _alumy_usage_libs)
_alumy_append_if_target(gRPC::grpc++ _alumy_usage_libs)
_alumy_append_if_target(gRPC::grpc _alumy_usage_libs)
_alumy_append_if_target(gRPC::address_sorting _alumy_usage_libs)
_alumy_append_if_target(re2::re2 _alumy_usage_libs)

# Abseil components commonly required by gRPC
foreach(_absl
    absl::base absl::strings absl::synchronization absl::time absl::status
    absl::statusor absl::hash absl::cord absl::span absl::variant absl::optional
    absl::inlined_vector absl::flat_hash_map absl::str_format absl::random_random)
    _alumy_append_if_target(${_absl} _alumy_usage_libs)
endforeach()

# c-ares
_alumy_append_if_target(c-ares::cares _alumy_usage_libs)

# Boost components - link the main headers target and available component targets
_alumy_append_if_target(Boost::headers _alumy_usage_libs)
_alumy_append_if_target(Boost::boost _alumy_usage_libs)
foreach(_boost_comp system filesystem thread chrono date_time regex serialization iostreams program_options)
    _alumy_append_if_target(Boost::${_boost_comp} _alumy_usage_libs)
endforeach()

# qpcpp static lib (imported by this config, if present)
_alumy_append_if_target(qpcpp _alumy_usage_libs)

list(REMOVE_DUPLICATES _alumy_usage_libs)
if(TARGET alumy::alumy AND _alumy_usage_libs)
    # Always propagate via INTERFACE for consumers
    target_link_libraries(alumy::alumy INTERFACE ${_alumy_usage_libs})
endif()

# Provide imported target for qpcpp if available (so exported link interfaces resolve)
if(NOT TARGET qpcpp)
    # Prefer an existing library file in the installed libdir
    find_library(_alumy_qpcpp_lib NAMES qpcpp
        PATHS ${ALUMY_LIB_DIR_CANDIDATES}
        NO_DEFAULT_PATH
    )
    if(_alumy_qpcpp_lib)
        add_library(qpcpp STATIC IMPORTED)
        # qpcpp is header-only + static lib; expose headers via INTERFACE include dir
        set_target_properties(qpcpp PROPERTIES
            IMPORTED_LOCATION "${_alumy_qpcpp_lib}"
            INTERFACE_INCLUDE_DIRECTORIES "${ALUMY_INCLUDE_DIR}"
        )
    endif()
endif()

#############################################################################
# Qt discovery to expose imported targets to downstreams
#############################################################################
set(QT_COMPONENTS Widgets Core Network SerialPort Multimedia Concurrent)

find_package(QT NAMES Qt6 Qt5 COMPONENTS ${QT_COMPONENTS} REQUIRED)
find_package(Qt${QT_VERSION_MAJOR} COMPONENTS ${QT_COMPONENTS} REQUIRED)

#############################################################################
# Dependency Resolution - Three Approaches (in priority order)
#############################################################################
# Function to find library files directly
function(alumy_find_library_direct var_name lib_names)
    set(_found_lib "")
    foreach(_name ${lib_names})
        find_library(_lib_${_name} NAMES ${_name}
            PATHS ${ALUMY_LIB_DIR_CANDIDATES}
            NO_DEFAULT_PATH
        )
        if(_lib_${_name})
            set(_found_lib ${_lib_${_name}})
            break()
        endif()
    endforeach()
    set(${var_name} ${_found_lib} PARENT_SCOPE)
endfunction()

# Function to find header files directly
function(alumy_find_header_direct var_name header_names)
    set(_found_header "")
    foreach(_name ${header_names})
        find_path(_header_${_name} NAMES ${_name}
            PATHS ${ALUMY_INCLUDE_DIR}
            NO_DEFAULT_PATH
        )
        if(_header_${_name})
            set(_found_header ${_header_${_name}})
            break()
        endif()
    endforeach()
    set(${var_name} ${_found_header} PARENT_SCOPE)
endfunction()

#############################################################################
# Library Linking Functions
#############################################################################

# Normalize library name to a canonical key
function(alumy_normalize_lib_name input_name output_var)
    string(TOLOWER "${input_name}" _name)
    if(_name STREQUAL "ssl")
        set(_name "openssl")
    elseif(_name STREQUAL "z")
        set(_name "zlib")
    elseif(_name STREQUAL "grpc++")
        set(_name "grpc")
    elseif(_name STREQUAL "abseil")
        set(_name "absl")
    elseif(_name STREQUAL "pthread" OR _name STREQUAL "thread" OR _name STREQUAL "threads")
        set(_name "threads")
    elseif(_name MATCHES "^qt[56]?.*")
        set(_name "qt")
    endif()
    set(${output_var} "${_name}" PARENT_SCOPE)
endfunction()

# Return appropriate link scope for a target: INTERFACE for interface libs, otherwise PRIVATE
function(alumy_get_link_scope target_name out_scope)
    get_target_property(_target_type ${target_name} TYPE)
    if(_target_type STREQUAL "INTERFACE_LIBRARY")
        set(_scope INTERFACE)
    else()
        set(_scope PRIVATE)
    endif()
    set(${out_scope} ${_scope} PARENT_SCOPE)
endfunction()

# Map canonical lib -> list of CMake targets to link if present
function(alumy_map_cmake_targets lib_name output_var)
    set(_targets "")
    if(lib_name STREQUAL "threads")
        set(_targets "Threads::Threads")
    elseif(lib_name STREQUAL "openssl")
        set(_targets "OpenSSL::SSL;OpenSSL::Crypto")
    elseif(lib_name STREQUAL "zlib")
        set(_targets "ZLIB::ZLIB")
    elseif(lib_name STREQUAL "protobuf")
        set(_targets "protobuf::libprotobuf")
    elseif(lib_name STREQUAL "grpc")
        set(_targets "gRPC::grpc++;gRPC::grpc;gRPC::address_sorting")
    elseif(lib_name STREQUAL "re2")
        set(_targets "re2::re2")
    elseif(lib_name STREQUAL "absl")
        set(_targets "absl::base;absl::strings;absl::synchronization;absl::time;absl::status;absl::statusor;absl::hash;absl::cord;absl::span;absl::variant;absl::optional;absl::inlined_vector;absl::flat_hash_map;absl::str_format;absl::random_random")
    elseif(lib_name STREQUAL "cares")
        set(_targets "c-ares::cares")
    elseif(lib_name STREQUAL "qpcpp")
        set(_targets "qpcpp")
    elseif(lib_name STREQUAL "qt")
        set(_targets "Qt${QT_VERSION_MAJOR}::Core;Qt${QT_VERSION_MAJOR}::Widgets;Qt${QT_VERSION_MAJOR}::Network;Qt${QT_VERSION_MAJOR}::SerialPort;Qt${QT_VERSION_MAJOR}::Multimedia;Qt${QT_VERSION_MAJOR}::Concurrent")
    elseif(lib_name STREQUAL "boost")
        set(_targets "Boost::headers;Boost::system;Boost::filesystem;Boost::thread;Boost::chrono;Boost::date_time;Boost::regex;Boost::serialization;Boost::iostreams;Boost::program_options")
    endif()
    set(${output_var} "${_targets}" PARENT_SCOPE)
endfunction()

# Map canonical lib -> pkg-config packages (space separated)
function(alumy_map_pkg_names lib_name output_var)
    set(_pkg "")
    if(lib_name STREQUAL "openssl")
        set(_pkg "openssl")
    elseif(lib_name STREQUAL "zlib")
        set(_pkg "zlib")
    elseif(lib_name STREQUAL "protobuf")
        set(_pkg "protobuf")
    elseif(lib_name STREQUAL "grpc")
        set(_pkg "grpc++ grpc")
    elseif(lib_name STREQUAL "re2")
        set(_pkg "re2")
    elseif(lib_name STREQUAL "qt")
        # Prefer Qt6, fall back to Qt5
        if(QT_VERSION_MAJOR EQUAL 6)
            set(_pkg "Qt6Core Qt6Widgets Qt6Network Qt6SerialPort Qt6Multimedia Qt6Concurrent")
        else()
            set(_pkg "Qt5Core Qt5Widgets Qt5Network Qt5SerialPort Qt5Multimedia Qt5Concurrent")
        endif()
    elseif(lib_name STREQUAL "boost")
        # Boost typically doesn't provide pkg-config files, but some distros might
        set(_pkg "boost")
    endif()
    set(${output_var} "${_pkg}" PARENT_SCOPE)
endfunction()

# Library component header mapping - easily extensible
function(alumy_init_library_header_mapping)
    # Boost component headers
    set(ALUMY_BOOST_HEADERS_system "boost/system/error_code.hpp" CACHE INTERNAL "")
    set(ALUMY_BOOST_HEADERS_filesystem "boost/filesystem.hpp" CACHE INTERNAL "")
    set(ALUMY_BOOST_HEADERS_thread "boost/thread.hpp" CACHE INTERNAL "")
    set(ALUMY_BOOST_HEADERS_chrono "boost/chrono.hpp" CACHE INTERNAL "")
    set(ALUMY_BOOST_HEADERS_date_time "boost/date_time.hpp" CACHE INTERNAL "")
    set(ALUMY_BOOST_HEADERS_regex "boost/regex.hpp" CACHE INTERNAL "")
    set(ALUMY_BOOST_HEADERS_serialization "boost/serialization/serialization.hpp" CACHE INTERNAL "")
    set(ALUMY_BOOST_HEADERS_iostreams "boost/iostreams/filtering_stream.hpp" CACHE INTERNAL "")
    set(ALUMY_BOOST_HEADERS_program_options "boost/program_options.hpp" CACHE INTERNAL "")
    
    # Header-only Boost libraries (commonly used)
    set(ALUMY_BOOST_HEADERS_ublas "boost/numeric/ublas/matrix.hpp" CACHE INTERNAL "")
    set(ALUMY_BOOST_HEADERS_math "boost/math/special_functions.hpp" CACHE INTERNAL "")
    set(ALUMY_BOOST_HEADERS_algorithm "boost/algorithm/string.hpp" CACHE INTERNAL "")
    set(ALUMY_BOOST_HEADERS_format "boost/format.hpp" CACHE INTERNAL "")
    set(ALUMY_BOOST_HEADERS_foreach "boost/foreach.hpp" CACHE INTERNAL "")
    set(ALUMY_BOOST_HEADERS_smart_ptr "boost/smart_ptr.hpp" CACHE INTERNAL "")
    
    # Add more libraries here as needed
    # set(ALUMY_QT_HEADERS_core "QtCore/qobject.h" CACHE INTERNAL "")
    # set(ALUMY_OPENSSL_HEADERS_ssl "openssl/ssl.h" CACHE INTERNAL "")
endfunction()

# Generic function to get representative headers for library components
function(alumy_get_library_component_headers lib_name component_list out_headers)
    alumy_init_library_header_mapping()
    set(_headers "")
    
    if(lib_name STREQUAL "boost")
        list(APPEND _headers "boost/version.hpp")  # Always include version header
        foreach(_comp ${component_list})
            string(TOUPPER "${lib_name}" _lib_upper)
            set(_var_name "ALUMY_${_lib_upper}_HEADERS_${_comp}")
            if(DEFINED ${_var_name})
                list(APPEND _headers "${${_var_name}}")
            else()
                # Fallback: try a generic pattern
                list(APPEND _headers "boost/${_comp}.hpp")
                message(STATUS "Using fallback header pattern for Boost component: ${_comp}")
            endif()
        endforeach()
    else()
        # For other libraries, use a generic pattern
        foreach(_comp ${component_list})
            list(APPEND _headers "${lib_name}/${_comp}.h")
        endforeach()
    endif()
    
    set(${out_headers} "${_headers}" PARENT_SCOPE)
endfunction()

# Map canonical lib -> direct lib files (names) and a representative header
function(alumy_map_direct_spec lib_name out_libs out_header)
    set(_libs "")
    set(_hdr "")
    if(lib_name STREQUAL "openssl")
        set(_libs "ssl;crypto")
        set(_hdr "openssl/ssl.h")
    elseif(lib_name STREQUAL "zlib")
        set(_libs "z")
        set(_hdr "zlib.h")
    elseif(lib_name STREQUAL "protobuf")
        set(_libs "protobuf")
        set(_hdr "google/protobuf/message.h")
    elseif(lib_name STREQUAL "grpc")
        set(_libs "grpc++;grpc")
        set(_hdr "grpcpp/grpcpp.h")
    elseif(lib_name STREQUAL "re2")
        set(_libs "re2")
        set(_hdr "re2/re2.h")
    elseif(lib_name STREQUAL "threads")
        set(_libs "pthread")
        set(_hdr "pthread.h")
    elseif(lib_name STREQUAL "absl")
        # Will be handled specially by direct-link function (glob libabsl_*.a)
        set(_libs "")
        set(_hdr "")
    elseif(lib_name STREQUAL "cares")
        set(_libs "cares")
        set(_hdr "ares.h")
    elseif(lib_name STREQUAL "qpcpp")
        set(_libs "qpcpp")
        set(_hdr "qpcpp.hpp")
    elseif(lib_name STREQUAL "qt")
        set(_libs "")
        set(_hdr "QtCore/qobject.h")
    elseif(lib_name STREQUAL "boost")
        set(_libs "boost_system;boost_filesystem;boost_thread;boost_chrono;boost_date_time;boost_regex;boost_serialization;boost_iostreams;boost_program_options")
        # Extract component names from library names  
        set(_components "")
        foreach(_lib ${_libs})
            string(REGEX REPLACE "^boost_" "" _comp "${_lib}")
            list(APPEND _components "${_comp}")
        endforeach()
        # Add commonly used header-only components
        list(APPEND _components "ublas" "math" "algorithm" "format" "foreach" "smart_ptr")
        # Get headers for these components
        alumy_get_library_component_headers("boost" "${_components}" _hdr)
    else()
        set(_libs "${lib_name}")
        set(_hdr "${lib_name}.h")
    endif()
    set(${out_libs} "${_libs}" PARENT_SCOPE)
    set(${out_header} "${_hdr}" PARENT_SCOPE)
endfunction()

# Try to link one library for a target via CMake targets
function(alumy_try_link_by_cmake_one target_name lib_key link_scope out_linked)
    set(_linked FALSE)
    alumy_map_cmake_targets(${lib_key} _cmake_targets)
    if(_cmake_targets)
        set(_any FALSE)
        foreach(_tgt ${_cmake_targets})
            if(TARGET ${_tgt})
                alumy_get_link_scope(${target_name} _scope)
                target_link_libraries(${target_name} ${_scope} ${_tgt})
                set(_any TRUE)
            endif()
        endforeach()
        if(_any)
            set(_linked TRUE)
        endif()
    endif()
    set(${out_linked} ${_linked} PARENT_SCOPE)
endfunction()

# Try to link one library for a target via pkg-config
function(alumy_try_link_by_pkgconfig_one target_name lib_key link_scope out_linked)
    set(_linked FALSE)
    find_package(PkgConfig QUIET)
    if(PKG_CONFIG_FOUND)
        alumy_map_pkg_names(${lib_key} _pkg_names)
        if(_pkg_names)
            string(REPLACE " " ";" _pkg_list "${_pkg_names}")
            set(_all_found TRUE)
            set(_all_includes "")
            set(_all_libs "")
            set(_all_cflags "")
            foreach(_pkg ${_pkg_list})
                pkg_check_modules(PC_${_pkg} QUIET ${_pkg})
                if(NOT PC_${_pkg}_FOUND)
                    set(_all_found FALSE)
                    break()
                endif()
                list(APPEND _all_includes ${PC_${_pkg}_INCLUDE_DIRS})
                list(APPEND _all_libs ${PC_${_pkg}_LIBRARIES})
                list(APPEND _all_cflags ${PC_${_pkg}_CFLAGS_OTHER})
            endforeach()
            if(_all_found)
                list(REMOVE_DUPLICATES _all_includes)
                list(REMOVE_DUPLICATES _all_libs)
                list(REMOVE_DUPLICATES _all_cflags)
                if(_all_includes)
                    target_include_directories(${target_name} ${link_scope} ${_all_includes})
                endif()
                if(_all_cflags)
                    target_compile_options(${target_name} ${link_scope} ${_all_cflags})
                endif()
                if(_all_libs)
                    target_link_libraries(${target_name} ${link_scope} ${_all_libs})
                endif()
                set(_linked TRUE)
            endif()
        endif()
    endif()
    set(${out_linked} ${_linked} PARENT_SCOPE)
endfunction()

# Try to link one library for a target via direct discovery
function(alumy_try_link_direct_one target_name lib_key link_scope out_linked)
    set(_linked FALSE)
    alumy_map_direct_spec(${lib_key} _spec_libs _spec_hdr)
    if(_spec_libs OR _spec_hdr)
        set(_found_headers "")
        if(_spec_hdr)
            alumy_find_header_direct(_hdr_found "${_spec_hdr}")
            if(_hdr_found)
                list(APPEND _found_headers ${_hdr_found})
            endif()
        endif()
        set(_found_libs "")
        if(_spec_libs)
            foreach(_l ${_spec_libs})
                alumy_find_library_direct(_lib_found "${_l}")
                if(_lib_found)
                    list(APPEND _found_libs ${_lib_found})
                endif()
            endforeach()
        endif()
        # Intentionally no direct-link fallback for Abseil; use CMake targets only
        if(_found_headers)
            list(REMOVE_DUPLICATES _found_headers)
            alumy_get_link_scope(${target_name} _scope)
            target_include_directories(${target_name} ${_scope} ${_found_headers})
        endif()
        if(_found_libs)
            alumy_get_link_scope(${target_name} _scope)
            target_link_libraries(${target_name} ${_scope} ${_found_libs})
            set(_linked TRUE)
        endif()
    endif()
    set(${out_linked} ${_linked} PARENT_SCOPE)
endfunction()

function(alumy_link_by_cmake target_name lib_names)
    get_target_property(_target_type ${target_name} TYPE)
    set(_link_scope PRIVATE)
    if(_target_type STREQUAL "INTERFACE_LIBRARY")
        set(_link_scope INTERFACE)
    endif()
    foreach(_n ${lib_names})
        alumy_normalize_lib_name(${_n} _k)
        alumy_try_link_by_cmake_one(${target_name} ${_k} ${_link_scope} _ok)
        if(_ok)
            message(STATUS "  Linked (CMake): ${_k}")
        endif()
    endforeach()
endfunction()

# Function to link libraries via PkgConfig
function(alumy_link_by_pkgconfig target_name lib_names)
    find_package(PkgConfig QUIET)
    get_target_property(_target_type ${target_name} TYPE)
    set(_link_scope PRIVATE)
    if(_target_type STREQUAL "INTERFACE_LIBRARY")
        set(_link_scope INTERFACE)
    endif()
    foreach(_n ${lib_names})
        alumy_normalize_lib_name(${_n} _k)
        alumy_try_link_by_pkgconfig_one(${target_name} ${_k} ${_link_scope} _ok)
        if(_ok)
            message(STATUS "  Linked (PkgConfig): ${_k}")
        endif()
    endforeach()
endfunction()

# Function to link libraries via direct discovery
function(alumy_link_direct target_name lib_names)
    get_target_property(_target_type ${target_name} TYPE)
    set(_link_scope PRIVATE)
    if(_target_type STREQUAL "INTERFACE_LIBRARY")
        set(_link_scope INTERFACE)
    endif()
    foreach(_n ${lib_names})
        alumy_normalize_lib_name(${_n} _k)
        alumy_try_link_direct_one(${target_name} ${_k} ${_link_scope} _ok)
        if(_ok)
            message(STATUS "  Linked (Direct): ${_k}")
        endif()
    endforeach()
endfunction()

# Convenience function to try linking libraries using all three approaches
function(alumy_link_libraries target_name lib_names)
    if(NOT TARGET ${target_name})
        message(FATAL_ERROR "Target ${target_name} does not exist")
    endif()
    
    # Determine link scope
    get_target_property(_target_type ${target_name} TYPE)
    set(_link_scope PRIVATE)
    if(_target_type STREQUAL "INTERFACE_LIBRARY")
        set(_link_scope INTERFACE)
    endif()

    message(STATUS "Attempting to link libraries for target: ${target_name}")
    
    # Track already linked canonical libs to avoid duplication
    set(_linked_keys "")
    
    foreach(_raw ${lib_names})
        if(NOT _raw)
            continue()
        endif()
        alumy_normalize_lib_name(${_raw} _key)
        if(NOT _key)
            continue()
        endif()
        list(FIND _linked_keys ${_key} _idx)
        if(_idx GREATER -1)
            continue()
        endif()
        
        # Prefer CMake targets from Alumy install, then direct archives in Alumy lib dirs.
        # System/pkg-config resolution is intentionally disabled.
        set(_done FALSE)
        alumy_try_link_by_cmake_one(${target_name} ${_key} ${_link_scope} _done)
        if(NOT _done)
            if(NOT _key STREQUAL "absl")
                alumy_try_link_direct_one(${target_name} ${_key} ${_link_scope} _done)
            endif()
        endif()

        if(_done)
            list(APPEND _linked_keys ${_key})
            message(STATUS "  Linked: ${_key}")
        else()
            message(STATUS "  Warning: Unable to link ${_key}")
        endif()
    endforeach()
    
    # Common system libs for non-INTERFACE targets
    if(NOT _target_type STREQUAL "INTERFACE_LIBRARY")
        if(UNIX AND NOT APPLE)
            target_link_libraries(${target_name} ${_link_scope} rt)
        endif()
        target_link_libraries(${target_name} ${_link_scope} m dl)
    endif()
    
    list(REMOVE_DUPLICATES _linked_keys)
    message(STATUS "Linked libraries for ${target_name}: ${_linked_keys}")
endfunction()

#############################################################################
# Convenience: minimal wrapper for common linking
#############################################################################

function(target_link_alumy target_name)
    if(NOT TARGET ${target_name})
        message(FATAL_ERROR "Target ${target_name} does not exist")
    endif()
    
    get_target_property(_target_type ${target_name} TYPE)
    set(_link_scope PRIVATE)
    if(_target_type STREQUAL "INTERFACE_LIBRARY")
        set(_link_scope INTERFACE)
    endif()
    
    # ALWAYS ensure Boost headers are available - this is the key fix
    if(TARGET Boost::headers)
        target_link_libraries(${target_name} ${_link_scope} Boost::headers)
        message(STATUS "Linked Boost::headers to ${target_name}")
    elseif(EXISTS "${ALUMY_INCLUDE_DIR}/boost")
        # Fallback: directly add include directory
        target_include_directories(${target_name} ${_link_scope} "${ALUMY_INCLUDE_DIR}")
        message(STATUS "Added Boost include directory ${ALUMY_INCLUDE_DIR} to ${target_name}")
    endif()
    
    # Link common libraries
    set(_libs "qt;boost;threads;protobuf;grpc;absl;cares;openssl;zlib;qpcpp")
    alumy_link_libraries(${target_name} "${_libs}")
    
    # Link main alumy target if present
    if(TARGET alumy::alumy)
        target_link_libraries(${target_name} ${_link_scope} alumy::alumy)
    endif()
    
    message(STATUS "Completed target_link_alumy for ${target_name}")
endfunction()

#############################################################################
# Debug function
#############################################################################

function(alumy_print_available_targets)
    message(STATUS "=== Available Alumy Targets ===")
    
    set(_all_possible_targets
        "alumy::alumy" "alumy::grpc++" "alumy::grpc" "alumy::gpr" 
        "alumy::address_sorting" "alumy::upb" "alumy::absl_base"
        "alumy::absl_strings" "alumy::absl_synchronization" "alumy::absl_time"
        "alumy::absl_status" "alumy::absl_statusor" "alumy::protobuf"
        "alumy::re2" "alumy::qpcpp"
    )
    
    foreach(_target ${_all_possible_targets})
        if(TARGET ${_target})
            get_target_property(_location ${_target} IMPORTED_LOCATION)
            message(STATUS "  ${_target} -> ${_location}")
        endif()
    endforeach()
    
    message(STATUS "System libraries:")
    if(TARGET Threads::Threads)
        message(STATUS "  Threads::Threads")
    endif()
    if(TARGET OpenSSL::SSL)
        message(STATUS "  OpenSSL::SSL, OpenSSL::Crypto")
    endif()
    if(TARGET ZLIB::ZLIB)
        message(STATUS "  ZLIB::ZLIB")
    endif()
    if(TARGET protobuf::libprotobuf)
        message(STATUS "  protobuf::libprotobuf")
    endif()
    if(TARGET gRPC::grpc++)
        message(STATUS "  gRPC::grpc++, gRPC::grpc")
    endif()
    
    message(STATUS "========================")
endfunction()

#############################################################################
# Final configuration
#############################################################################

# Set version variables
set(ALUMY_VERSION "@PROJECT_VERSION@")
set(ALUMY_VERSION_MAJOR "@PROJECT_VERSION_MAJOR@")
set(ALUMY_VERSION_MINOR "@PROJECT_VERSION_MINOR@")
set(ALUMY_VERSION_PATCH "@PROJECT_VERSION_PATCH@")

message(STATUS "Alumy library configuration completed - version ${ALUMY_VERSION}")
message(STATUS "Use target_link_alumy(your_target) for essential dependencies")
message(STATUS "Use alumy_print_available_targets() to view available targets")
message(STATUS "")
message(STATUS "Link helpers: alumy_link_libraries | alumy_link_by_cmake | alumy_link_direct")
message(STATUS "Usage: alumy_link_libraries(target \"openssl;zlib;protobuf;grpc;qt;threads\")")

# Mark package as found
set(alumy_FOUND TRUE)